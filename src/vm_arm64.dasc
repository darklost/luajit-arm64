|// Low-level VM code for ARM CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2014 Mike Pall. See Copyright Notice in luajit.h
|
|.arch a64
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|// Note: The ragged indentation of the instructions is intentional.
|//       The starting columns indicate data dependencies.
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|
|// The following must be C callee-save.
|.define MASKR8,    w19    // 255*8 constant for fast bytecode decoding.
|
|.define KBASE,     x20    // Constants of current Lua function.
|.define PC,        x21    // Next PC.
|.define DISPATCH,  x22    // Opcode dispatch table.
|.define LREG,      x23    // Register holding lua_State (also in SAVE_L).
|.define BASE,      x24    // Base of current Lua stack frame.
|.define RA,        x25
|.define RC,        x26
|.define RB,        x27
|.define OP,        x27    // Overlaps RB, must not be lr.
|.define INS,       x28
|
|.define KBASEw,    w20    // Constants of current Lua function.
|.define PCw,       w21    // Next PC.
|.define DISPATCHw, w22    // Opcode dispatch table.
|.define LREGw,     w23    // Register holding lua_State (also in SAVE_L).
|.define BASEw,     w24    // Base of current Lua stack frame.
|.define RAw,       w25
|.define RCw,       w26
|.define RBw,       w27
|.define OPw,       w27    // Overlaps RB, must not be lr.
|.define INSw,      w28
|
|// Calling conventions. Also used as temporaries.
|.define CARG1,     x0
|.define CARG2,     x1
|.define CARG3,     x2
|.define CARG4,     x3
|.define CARG5,     x4
|.define CARG6,     x5
|.define CARG7,     x6
|.define CARG8,     x7
|.define CARG1w,    w0
|.define CARG2w,    w1
|.define CARG3w,    w2
|.define CARG4w,    w3
|.define CARG5w,    w4
|.define CARG6w,    w5
|.define CARG7w,    w6
|.define CARG8w,    w7
|
|.define CRET1,     x0
|.define CRET2,     x1
|.define CRET1w,    w0
|.define CRET2w,    w1
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|.define CFRAME_SPACE,    32     // align on 16 bytes
|.define SAVE_ERRF,    [sp, #24]
|.define SAVE_NRES,    [sp, #20]
|.define SAVE_CFRAME,    [sp, #16]
|.define SAVE_L,    [sp, #12]
|.define SAVE_PC,    [sp, #8]
|.define SAVE_MULTRES,    [sp, #4]
|.define ARG9,        [sp]
|
|.define TMPDhi,    [sp, #4]
|.define TMPDlo,    [sp]
|.define TMPD,      [sp]
|.define TMPDp,     sp
|
|.if FPU
|.macro saveregs
|  sub sp, sp, #16
|  stp x29, x30, [sp], #-16
|  add x29, sp, #16
|  stp x27, x28, [sp], #-16
|  stp x25, x26, [sp], #-16
|  stp x23, x24, [sp], #-16
|  stp x21, x22, [sp], #-16
|  stp x19, x20, [sp], #-64
|// no pre-index variant is supported for st1
|  st1 {v8.1d, v9.1d, v10.1d, v11.1d}, [sp], #32
|  st1 {v12.1d, v13.1d, v14.1d, v15.1d}, [sp], #32
|  sub sp, sp, #CFRAME_SPACE+64
|.endmacro
|.macro restoreregs_ret
|  add sp, sp, CFRAME_SPACE
|  ld1 {v8.1d, v9.1d, v10.1d, v11.1d}, [sp], #32
|  ld1 {v12.1d, v13.1d, v14.1d, v15.1d}, [sp], #32
|  ldp x19, x20, [sp], #16
|  ldp x21, x22, [sp], #16
|  ldp x23, x24, [sp], #16
|  ldp x25, x26, [sp], #16
|  ldp x27, x28, [sp], #16
|  ldp x29, x30, [sp], #16
|  ret
|.endmacro
|.else
|// NYI
|.endif
|
|// Type definitions. Some of these are only used for documentation.
|.type L,        lua_State,    LREG
|.type Lw,        lua_State,    LREGw
|.type GL,        global_State
|.type TVALUE,        TValue
|.type GCOBJ,        GCobj
|.type STR,        GCstr
|.type TAB,        GCtab
|.type LFUNC,        GCfuncL
|.type CFUNC,        GCfuncC
|.type PROTO,        GCproto
|.type UPVAL,        GCupval
|.type NODE,        Node
|.type NARGS8,        int
|.type TRACE,        GCtrace
|.type SBUF,        SBuf
|
|//-----------------------------------------------------------------------
|
|// Trap for not-yet-implemented parts.
|.macro NYI; ud; .endmacro
|
|//-----------------------------------------------------------------------
|
|// Access to frame relative to BASE.
|.define FRAME_FUNC,    #-8
|.define FRAME_PC,    #-4
|
|.macro decode_RA8, dst, ins; and dst, MASKR8, ins, lsr #5; .endmacro
|.macro decode_RB8, dst, ins; and dst, MASKR8, ins, lsr #21; .endmacro
|.macro decode_RC8, dst, ins; and dst, MASKR8, ins, lsr #13; .endmacro
|.macro decode_RD, dst, ins; lsr dst, ins, #16; .endmacro
|.macro decode_OP, dst, ins; and dst, ins, #255; .endmacro
|
|// Instruction fetch.
|.macro ins_NEXT1
|  ldrb OPw, [PC]
|.endmacro
|.macro ins_NEXT2
|   ldr INSw, [PC], #4
|.endmacro
|// Instruction decode+dispatch.
|.macro ins_NEXT3
|  ldr OP, [DISPATCH, OP, lsl #3]
|   decode_RA8 RAw, INSw
|   decode_RD RCw, INSw
|  br OP
|.endmacro
|.macro ins_NEXT
|  ins_NEXT1
|  ins_NEXT2
|  ins_NEXT3
|.endmacro
|
|// Instruction footer.
|.if 1
|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
|  .define ins_next, ins_NEXT
|  .define ins_next_, ins_NEXT
|  .define ins_next1, ins_NEXT1
|  .define ins_next2, ins_NEXT2
|  .define ins_next3, ins_NEXT3
|.else
|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
|  // Affects only certain kinds of benchmarks (and only with -j off).
|  .macro ins_next
|    b ->ins_next
|  .endmacro
|  .macro ins_next1
|  .endmacro
|  .macro ins_next2
|  .endmacro
|  .macro ins_next3
|    b ->ins_next
|  .endmacro
|  .macro ins_next_
|  ->ins_next:
|    ins_NEXT
|  .endmacro
|.endif
|
|// Avoid register name substitution for field name.
#define field_pc    pc
|
|// Call decode and dispatch.
|.macro ins_callt
|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
|  ldr PCw, LFUNC:CARG3->field_pc
|  ldrb OPw, [PC]  // STALL: load PC. early PC.
|   ldr INSw, [PC], #4
|  ldr OP, [DISPATCH, OP, lsl #3]  // STALL: load OP. early OP.
|   decode_RA8 RAw, INSw
|   add RA, RA, BASE
|  br OP
|.endmacro
|
|.macro ins_call
|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
|  str PCw, [BASE, FRAME_PC]
|  ins_callt  // STALL: locked PC.
|.endmacro
|
|//-----------------------------------------------------------------------
|
|// Macros to test operand types.
|.macro checktp, reg, tp; cmn reg, #-tp; .endmacro
|.macro checktpeq, reg, tp; ccmn reg, #-tp, #0, eq; .endmacro
|.macro checktpne, reg, tp; ccmn reg, #-tp, #4, ne; .endmacro
|.macro checkstr, reg, target; checktp reg, LJ_TSTR; b.ne target; .endmacro
|.macro checktab, reg, target; checktp reg, LJ_TTAB; b.ne target; .endmacro
|.macro checkfunc, reg, target; checktp reg, LJ_TFUNC; b.ne target; .endmacro
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)    (GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)    (GG_DISP2J + (int)offsetof(jit_State, field))
|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|
|.macro hotcheck, delta
|  lsr CARG1, PC, #1
|  and CARG1, CARG1, #126
|  sub CARG1, CARG1, #-GG_DISP2HOT
|  ldrh CARG2, [DISPATCH, CARG1]
|  subs CARG2, CARG2, #delta
|  strh CARG2, [DISPATCH, CARG1]
|.endmacro
|
|.macro hotloop
|  hotcheck HOTCOUNT_LOOP
|  b.lo ->vm_hotloop
|.endmacro
|
|.macro hotcall
|  hotcheck HOTCOUNT_CALL
|  b.lo ->vm_hotcall
|.endmacro
|
|// Set current VM state.
|.macro mv_vmstate, reg, st; movn reg, #LJ_VMST_..st; .endmacro
|.macro st_vmstate, reg; str reg, [DISPATCH, #DISPATCH_GL(vmstate)]; .endmacro
|
|// Move table write barrier back. Overwrites mark and tmp.
|.macro barrierback, tab, mark, tmp
|  ldr tmp, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
|   and mark, mark, #~LJ_GC_BLACK       // black2gray(tab), ~LJ_GC_BLACK=0xfffffffb, bitmask imm
|  str tab, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
|   strb mark, tab->marked
|  str tmp, tab->gclist
|.endmacro
|
|
|//-----------------------------------------------------------------------

#if !LJ_DUALNUM
#error "Only dual-number mode supported for ARM target"
#endif

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  |.code_sub
  |
  |//-----------------------------------------------------------------------
  |//-- Return handling ----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_returnp:
  |  // See vm_return. Also: RB = previous base.
  |  tst PCw, #FRAME_P  //FRAME_P = 4,  bitmask immediate
  |  b.eq ->cont_dispatch
  |
  |  // Return from pcall or xpcall fast func.
  |  ldr PCw, [RB, FRAME_PC]        // Fetch PC of previous frame.
  |   mov CARG2w, #LJ_TTRUE         // inverted wide imm
  |  mov BASE, RB
  |  // Prepending may overwrite the pcall frame, so do it at the end.
  |   str CARG2w, [RA, FRAME_PC]        // Prepend true to results.
  |  sub RA, RA, #8
  |
  |->vm_returnc:
  |  adds RC, RC, #8            // RC = (nresults+1)*8.
  |  mov CRET1, #LUA_YIELD
  |  b.eq ->vm_unwind_c_eh
  |  str RCw, SAVE_MULTRES
  |  ands CARG1, PC, #FRAME_TYPE
  |  b.eq ->BC_RET_Z            // Handle regular return to Lua.
  |
  |->vm_return:
  |  // BASE = base, RA = resultptr, RC/MULTRES = (nresults+1)*8, PC = return
  |  // CARG1 = PC & FRAME_TYPE
  |  and RB, PC, #~((intptr_t)FRAME_TYPEP)
  |   cmp CARG1, #FRAME_C
  |  sub RB, BASE, RB            // RB = previous base.
  |   b.ne ->vm_returnp
  |
  |  str RB, L->base
  |   ldr KBASEw, SAVE_NRES
  |    mv_vmstate CARG4w, C
  |   sub BASE, BASE, #8
  |  subs CARG3, RC, #8
  |   lsl KBASE, KBASE, #3        // KBASE = (nresults_wanted+1)*8
  |    st_vmstate CARG4w
  |  b.eq >2
  |1:
  |  subs CARG3, CARG3, #8
  |   ldr CARG1, [RA], #8
  |   str CARG1, [BASE], #8
  |  b.ne <1
  |2:
  |  cmp KBASE, RC            // More/less results wanted?
  |  b.ne >6
  |3:
  |  str BASE, L->top            // Store new top.
  |
  |->vm_leave_cp:
  |  ldr RCw, SAVE_CFRAME        // Restore previous C frame.
  |   mov CRET1, #0            // Ok return status for vm_pcall.
  |  str RC, L->cframe
  |
  |->vm_leave_unw:
  |  restoreregs_ret
  |
  |6:              // KBASE: (nresults_wanted+1)*8, RC: (nresults_actual+1)*8
  |  b.lt >7                // Less results wanted?
  |  // More results wanted. Check stack size and fill up results with nil.
  |  ldr CARG3w, L->maxstack
  |   mov CARG2, #LJ_TNIL
  |  cmp BASE, CARG3
  |  b.hs >8
  |   str CARG2w, [BASE, #4]
  |  add RC, RC, #8
  |  add BASE, BASE, #8
  |  b <2
  |
  |7:  // Less results wanted.
  |  sub CARG1, RC, KBASE
  |  sub CARG2, BASE, CARG1
  |  cmp KBASE, #0            // LUA_MULTRET+1 case?
  |  csel BASE, CARG2, BASE, ne     // Either keep top or shrink it.
  |  b <3
  |
  |8:  // Corner case: need to grow stack for filling up results.
  |  // This can happen if:
  |  // - A C function grows the stack (a lot).
  |  // - The GC shrinks the stack in between.
  |  // - A return back from a lua_call() with (high) nresults adjustment.
  |  str BASE, L->top            // Save current top held in BASE (yes).
  |  mov CARG2w, KBASEw
  |  mov CARG1, L
  |  bl extern lj_state_growstack    // (lua_State *L, int n)
  |  ldr BASE, L->top            // Need the (realloced) L->top in BASE.
  |  b <2
  |
  |->vm_unwind_c:            // Unwind C stack, return from vm_pcall.
  |  // (void *cframe, int errcode)
  |  mov sp, CARG1
  |  mov CRET1w, CARG2w
  |->vm_unwind_c_eh:            // Landing pad for external unwinder.
  |  ldr Lw, SAVE_L
  |   mv_vmstate CARG4w, C
  |  ldr GL:CARG3w, L->glref
  |   str CARG4w, GL:CARG3->vmstate
  |  b ->vm_leave_unw
  |
  |->vm_unwind_ff:            // Unwind C stack, return from ff pcall.
  |  // (void *cframe)
  |  and sp, CARG1, #CFRAME_RAWMASK   // 0xfffffffffffffffc 
  |->vm_unwind_ff_eh:            // Landing pad for external unwinder.
  |  ldr Lw, SAVE_L
  |   mov MASKR8, #255
  |    mov RCw, #16            // 2 results: false + error message.
  |   lsl MASKR8, MASKR8, #3        // MASKR8 = 255*8.
  |  ldr BASE, L->base
  |   ldr DISPATCHw, L->glref        // Setup pointer to dispatch table.
  |    mov CARG1w, #LJ_TFALSE
  |  sub RA, BASE, #8            // Results start at BASE-8.
  |  ldr PCw, [BASE, FRAME_PC]        // Fetch PC of previous frame.
  |   add DISPATCH, DISPATCH, #GG_G2DISP
  |   mv_vmstate CARG2w, INTERP
  |    str CARG1w, [BASE, #-4]        // Prepend false to error message.
  |   st_vmstate CARG2w
  |  b ->vm_returnc
  |
  |//-----------------------------------------------------------------------
  |//-- Grow stack for calls -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_growstack_c:            // Grow stack for C function.
  |  // CARG1 = L
  |  mov CARG2, #LUA_MINSTACK
  |  b >2
  |
  |->vm_growstack_l:            // Grow stack for Lua function.
  |  // BASE = new base, RA = BASE+framesize*8, RC = nargs*8, PC = first PC
  |  add RC, BASE, RC
  |   sub RA, RA, BASE
  |    mov CARG1, L
  |  str BASE, L->base
  |   add PC, PC, #4            // Must point after first instruction.
  |  str RC, L->top
  |   lsr CARG3, RA, #3
  |2:
  |  // L->base = new base, L->top = top
  |  str PCw, SAVE_PC
  |  bl extern lj_state_growstack    // (lua_State *L, int n)
  |  ldr BASE, L->base
  |   ldr RC, L->top
  |  ldr LFUNC:CARG3w, [BASE, FRAME_FUNC]
  |   sub NARGS8:RC, RC, BASE
  |  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
  |  ins_callt                // Just retry the call.
  |
  |//-----------------------------------------------------------------------
  |//-- Entry points into the assembler VM ---------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_resume:                // Setup C frame and resume thread.
  |  // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
  |  saveregs
  |  mov L, CARG1
  |    ldr DISPATCHw, L:CARG1->glref    // Setup pointer to dispatch table.
  |  mov BASE, CARG2
  |    add DISPATCH, DISPATCH, #GG_G2DISP
  |   str Lw, SAVE_L
  |  mov PCw, #FRAME_CP
  |   str CARG3w, SAVE_NRES
  |    add CARG2, sp, #CFRAME_RESUME
  |  ldrb CARG1w, L->status
  |   str CARG3w, SAVE_ERRF      // TODO: check wzr may be better than CARG3w
  |   str Lw, SAVE_PC            // Any value outside of bytecode is ok.
  |   str CARG3w, SAVE_CFRAME
  |  cmp CARG1, #0
  |    str CARG2, L->cframe
  |  b.eq >3
  |
  |  // Resume after yield (like a return).
  |  str Lw, [DISPATCH, #DISPATCH_GL(cur_L)]
  |  mov RA, BASE
  |   ldr BASE, L->base
  |   ldr CARG1, L->top
  |    mov MASKR8, #255
  |     strb CARG3w, L->status
  |   sub RC, CARG1, BASE
  |  ldr PCw, [BASE, FRAME_PC]
  |    lsl MASKR8, MASKR8, #3        // MASKR8 = 255*8.
  |     mv_vmstate CARG2w, INTERP
  |   add RC, RC, #8
  |  ands CARG1, PC, #FRAME_TYPE //FRAME_TYPE = 3 is a bitmask immediate
  |     st_vmstate CARG2w
  |   str RCw, SAVE_MULTRES
  |  b.eq ->BC_RET_Z
  |  b ->vm_return
  |
  |->vm_pcall:                // Setup protected C frame and enter VM.
  |  // (lua_State *L, TValue *base, int nres1, ptrdiff_t ef)
  |  saveregs
  |  mov PC, #FRAME_CP
  |  str CARG4w, SAVE_ERRF
  |  b >1
  |
  |->vm_call:                // Setup C frame and enter VM.
  |  // (lua_State *L, TValue *base, int nres1)
  |  saveregs
  |  mov PC, #FRAME_C
  |
  |1:  // Entry point for vm_pcall above (PC = ftype).
  |  ldr RC, L:CARG1->cframe
  |   str CARG3w, SAVE_NRES
  |    mov L, CARG1
  |   str CARG1w, SAVE_L
  |    ldr DISPATCHw, L->glref        // Setup pointer to dispatch table.
  |     mov BASE, CARG2
  |   str CARG1w, SAVE_PC        // Any value outside of bytecode is ok.
  |  str RCw, SAVE_CFRAME
  |    add DISPATCH, DISPATCH, #GG_G2DISP
  |  str sp, L->cframe            // Add our C frame to cframe chain.
  |
  |3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
  |  str Lw, [DISPATCH, #DISPATCH_GL(cur_L)]
  |  ldr RB, L->base            // RB = old base (for vmeta_call).
  |   ldr CARG1, L->top
  |    mov MASKR8, #255
  |  add PC, PC, BASE
  |    lsl MASKR8, MASKR8, #3        // MASKR8 = 255*8.
  |  sub PC, PC, RB            // PC = frame delta + frame type
  |    mv_vmstate CARG2w, INTERP
  |   sub NARGS8:RC, CARG1, BASE
  |    st_vmstate CARG2w
  |
  |->vm_call_dispatch:
  |  // RB = old base, BASE = new base, RC = nargs*8, PC = caller PC
  |  ldp CARG3w, CARG4w, [BASE, FRAME_FUNC]
  |  checkfunc CARG4w, ->vmeta_call
  |
  |->vm_call_dispatch_f:
  |  ins_call
  |  // BASE = new base, CARG3 = func, RC = nargs*8, PC = caller PC
  |
  |->vm_cpcall:                // Setup protected C frame, call C.
  |  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
  |  saveregs
  |  mov L, CARG1
  |   ldr RAw, L:CARG1->stack
  |  str CARG1w, SAVE_L
  |    ldr DISPATCHw, L->glref        // Setup pointer to dispatch table.
  |   ldr RB, L->top
  |  str CARG1w, SAVE_PC            // Any value outside of bytecode is ok.
  |  ldr RC, L->cframe
  |    add DISPATCH, DISPATCH, #GG_G2DISP
  |   sub RA, RA, RB            // Compute -savestack(L, L->top).
  |  mov RB, #0
  |   str RAw, SAVE_NRES            // Neg. delta means cframe w/o frame.
  |  str RBw, SAVE_ERRF            // No error function.
  |  str RCw, SAVE_CFRAME
  |  str sp, L->cframe            // Add our C frame to cframe chain.
  |    str Lw, [DISPATCH, #DISPATCH_GL(cur_L)]
  |  blr CARG4            // (lua_State *L, lua_CFunction func, void *ud)
  |  cmp CRET1, #0
  |   mov BASE, CRET1
  |   mov PC, #FRAME_CP
  |  b.ne <3                // Else continue with the call.
  |  b ->vm_leave_cp            // No base? Just remove C frame.
  |
  |//-----------------------------------------------------------------------
  |//-- Metamethod handling ------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |//-- Continuation dispatch ----------------------------------------------
  |
  |->cont_dispatch:
  |  // BASE = meta base, RA = resultptr, RC = (nresults+1)*8
  |  ldr LFUNC:CARG3w, [RB, FRAME_FUNC]
  |    ldr CARG1w, [BASE, #-16]        // Get continuation.
  |   mov CARG4, BASE
  |   mov BASE, RB            // Restore caller BASE.
  |.if FFI
  |    cmp CARG1, #1
  |.endif
  |   ldr PCw, [CARG4, #-12]        // Restore PC from [cont|PC].
  |  ldr CARG3w, LFUNC:CARG3->field_pc
  |    mov INSw, #LJ_TNIL
  |    add CARG2, RA, RC
  |    str INSw, [CARG2, #-4]        // Ensure one valid arg.
  |.if FFI
  |    b.ls >1
  |.endif
  |  ldr KBASEw, [CARG3, #PC2PROTO(k)]
  |  // BASE = base, RA = resultptr, CARG4 = meta base
  |    br CARG1
  |
  |.if FFI
  |1:
  |  b.eq ->cont_ffi_callback        // cont = 1: return from FFI callback.
  |  // cont = 0: tailcall from C function.
  |  ldr CARG3w, [BASE, FRAME_FUNC]
  |   sub CARG4, CARG4, #16
  |   sub RC, CARG4, BASE
  |  b ->vm_call_tail
  |.endif
  |
  |->cont_cat:                // RA = resultptr, CARG4 = meta base
  |  ldr INSw, [PC, #-4]
  |   sub CARG2, CARG4, #16
  |   ldr CARG3, [RA]         // load 8 bytes
  |     str BASE, L->base
  |  decode_RB8 RCw, INSw
  |  add CARG1, BASE, RC
  |  subs CARG1, CARG2, CARG1
  |   decode_RA8 RAw, INSw
  |  b.eq >1
  |   str CARG3, [CARG2]      // store 8 bytes
  |   mov CARG3, CARG1
  |  b ->BC_CAT_Z
  |1:
  |   str CARG3, [BASE, RA]   // store 8 bytes
  |  b ->cont_nop
  |
  |//-- Table indexing metamethods -----------------------------------------
  |
  |->vmeta_tgets1:
  |  add CARG2, BASE, RB
  |  b >2
  |
  |->vmeta_tgets:
  |  sub CARG2, DISPATCH, #-DISPATCH_GL(tmptv)
  |   mov CARG4w, #LJ_TTAB
  |  stp TAB:RBw, CARG4w, [CARG2]
  |2:
  |   mov CARG4w, #LJ_TSTR
  |  stp STR:RCw, CARG4w, TMPD
  |  mov CARG3, TMPDp
  |  b >1
  |
  |->vmeta_tgetb:            // RC = index
  |  decode_RB8 RBw, INSw
  |  add CARG2, BASE, RB
  |   mov CARG4w, #LJ_TISNUM
  |   stp RCw, CARG4w, TMPD
  |  mov CARG3, TMPDp
  |  b >1
  |
  |->vmeta_tgetv:
  |  //add CARG2, BASE, RB
  |  // add CARG3, BASE, RC
  |  mov CARG2, RB
  |  mov CARG3, RC
  |1:
  |   str BASE, L->base
  |  mov CARG1, L
  |   str PCw, SAVE_PC
  |  bl extern lj_meta_tget        // (lua_State *L, TValue *o, TValue *k)
  |  // Returns TValue * (finished) or NULL (metamethod).
  |  cbz CRET1, >3
  |  ldr CARG3, [CRET1]
  |   ins_next1
  |   ins_next2
  |  str CARG3, [RA]
  |   ins_next3
  |
  |3:  // Call __index metamethod.
  |  // BASE = base, L->top = new base, stack = cont/func/t/k
  |   sub CARG1, BASE, #FRAME_CONT
  |  ldr BASE, L->top
  |    mov NARGS8:RC, #16        // 2 args for func(t, k).
  |    str PCw, [BASE, #-12]        // [cont|PC]
  |   sub PC, BASE, CARG1
  |  ldr LFUNC:CARG3w, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  |  b ->vm_call_dispatch_f
  |
  |->vmeta_tgetr:
  |  bl extern lj_tab_getinth        // (GCtab *t, int32_t key)
  |  // Returns cTValue * or NULL.
  |  mov CARG2w, #LJ_TNIL
  |  cbz CRET1, ->BC_TGETR_Z
  |  ldp CARG1w, CARG2w, [CRET1]
  |  b ->BC_TGETR_Z
  |
  |//-----------------------------------------------------------------------
  |
  |->vmeta_tsets1:
  |  mov CARG2, RB
  |  b >2
  |
  |->vmeta_tsets:
  |  sub CARG2, DISPATCH, #-DISPATCH_GL(tmptv)
  |   mov CARG4w, #LJ_TTAB
  |  stp TAB:RBw, CARG4w, [CARG2]
  |2:
  |   mov CARG4w, #LJ_TSTR
  |  stp STR:RCw, CARG4w, TMPD
  |  mov CARG3, TMPDp
  |  b >1
  |
  |->vmeta_tsetb:            // RB = table, RC = index
  |  mov CARG2, RB
  |   mov CARG4w, #LJ_TISNUM
  |   stp RCw, CARG4w, TMPD
  |  mov CARG3, TMPDp
  |  b >1
  |
  |->vmeta_tsetv:
  |  // RA = src*8, RB = table, RC = key
  |  mov CARG2, RB
  |   mov CARG3, RC
  |1:
  |   str BASE, L->base
  |  mov CARG1, L
  |   str PCw, SAVE_PC
  |  bl extern lj_meta_tset        // (lua_State *L, TValue *o, TValue *k)
  |  // Returns TValue * (finished) or NULL (metamethod).
  |   ldr CARG3, [BASE, RA]        // load 8 bytes
  |  cbz CRET1, >3
  |   ins_next1
  |  // NOBARRIER: lj_meta_tset ensures the table is not black.
  |  str CARG3, [CRET1]            // store 8 bytes
  |   ins_next2
  |   ins_next3
  |
  |3:  // Call __newindex metamethod.
  |  // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
  |   sub CARG1, BASE, #FRAME_CONT
  |  ldr BASE, L->top
  |    mov NARGS8:RC, #24        // 3 args for func(t, k, v).
  |   str CARG3, [BASE, #16]        // Copy value(8 bytes) to third argument.
  |    str PCw, [BASE, #-12]        // [cont|PC]
  |   sub PC, BASE, CARG1
  |  ldr LFUNC:CARG3w, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  |  b ->vm_call_dispatch_f
  |
  |->vmeta_tsetr:
  |  str BASE, L->base
  |  str PCw, SAVE_PC
  |  bl extern lj_tab_setinth  // (lua_State *L, GCtab *t, int32_t key)
  |  // Returns TValue *.
  |  b ->BC_TSETR_Z
  |
  |//-- Comparison metamethods ---------------------------------------------
  |
  |->vmeta_comp:
  |  mov CARG1, L
  |   sub PC, PC, #4
  |  mov CARG2, RA
  |   str BASE, L->base
  |  mov CARG3, RC
  |   str PCw, SAVE_PC
  |  decode_OP CARG4w, INSw
  |  bl extern lj_meta_comp  // (lua_State *L, TValue *o1, *o2, int op)
  |  // Returns 0/1 or TValue * (metamethod).
  |3:
  |  cmp CRET1, #1
  |  b.hi ->vmeta_binop
  |4:
  |  ldrh RBw, [PC, #2]
  |   add PC, PC, #4
  |  add RB, PC, RB, lsl #2
  |  sub RB, RB, #0x20, lsl #12   // RB -= 0x20000
  |  csel PC, RB, PC, hs          // PC = RB if hs
  |->cont_nop:
  |  ins_next
  |
  |->cont_ra:                // RA = resultptr
  |  ldr INSw, [PC, #-4]
  |   ldr CARG1, [RA]
  |  decode_RA8 CARG3w, INSw
  |   str CARG1, [BASE, CARG3]
  |  b ->cont_nop
  |
  |->cont_condt:            // RA = resultptr
  |  ldr CARG2w, [RA, #4]
  |   mov CARG1w, #LJ_TTRUE
  |  cmp CARG1w, CARG2w            // Branch if result is true.
  |  b <4
  |
  |->cont_condf:            // RA = resultptr
  |  ldr CARG2w, [RA, #4]
  |  checktp CARG2w, LJ_TFALSE        // Branch if result is false.
  |  b <4
  |
  |->vmeta_equal:
  |  // CARG2, CARG3, CARG4 are already set by BC_ISEQV/BC_ISNEV.
  |  sub PC, PC, #4
  |   str BASE, L->base
  |   mov CARG1, L
  |  str PCw, SAVE_PC
  |  bl extern lj_meta_equal  // (lua_State *L, GCobj *o1, *o2, int ne)
  |  // Returns 0/1 or TValue * (metamethod).
  |  b <3
  |
  |->vmeta_equal_cd:
  |.if FFI
  |  sub PC, PC, #4
  |   str BASE, L->base
  |   mov CARG1, L
  |   mov CARG2, INS
  |  str PCw, SAVE_PC
  |  bl extern lj_meta_equal_cd        // (lua_State *L, BCIns op)
  |  // Returns 0/1 or TValue * (metamethod).
  |  b <3
  |.endif
  |
  |->vmeta_istype:
  |  sub PC, PC, #4
  |   str BASE, L->base
  |   mov CARG1, L
  |   lsr CARG2, RA, #3
  |   mov CARG3, RC
  |  str PCw, SAVE_PC
  |  bl extern lj_meta_istype  // (lua_State *L, BCReg ra, BCReg tp)
  |  b ->cont_nop
  |
  |//-- Arithmetic metamethods ---------------------------------------------
  |
  |->vmeta_arith_vn:
  |  decode_RB8 RBw, INSw
  |   decode_RC8 RCw, INSw
  |  add CARG3, BASE, RB
  |   add CARG4, KBASE, RC
  |  b >1
  |
  |->vmeta_arith_nv:
  |  decode_RB8 RBw, INSw
  |   decode_RC8 RCw, INSw
  |  add CARG4, BASE, RB
  |   add CARG3, KBASE, RC
  |  b >1
  |
  |->vmeta_unm:
  |  ldr INSw, [PC, #-8]
  |   sub PC, PC, #4
  |  add CARG3, BASE, RC
  |  add CARG4, BASE, RC
  |  b >1
  |
  |->vmeta_arith_vv:
  |  decode_RB8 RBw, INSw
  |   decode_RC8 RCw, INSw
  |  add CARG3, BASE, RB
  |   add CARG4, BASE, RC
  |1:
  |  decode_OP CARG5w, INSw
  |   add CARG2, BASE, RA
  |    str BASE, L->base
  |   mov CARG1, L
  |    str PCw, SAVE_PC
  |  bl extern lj_meta_arith  // (lua_State *L, TValue *ra,*rb,*rc, BCReg op)
  |  // Returns NULL (finished) or TValue * (metamethod).
  |  cmp CRET1, #0
  |  b.eq ->cont_nop
  |
  |  // Call metamethod for binary op.
  |->vmeta_binop:
  |  // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
  |  sub CARG2, CRET1, BASE
  |   str PCw, [CRET1, #-12]        // [cont|PC]
  |  add PC, CARG2, #FRAME_CONT
  |   mov BASE, CRET1
  |    mov NARGS8:RCw, #16        // 2 args for func(o1, o2).
  |  b ->vm_call_dispatch
  |
  |->vmeta_len:
  |  add CARG2, BASE, RC
  |   str BASE, L->base
  |  mov CARG1, L
  |   str PCw, SAVE_PC
  |  bl extern lj_meta_len        // (lua_State *L, TValue *o)
  |  // Returns NULL (retry) or TValue * (metamethod base).
#if LJ_52
  |  cmp CRET1, #0
  |  b.ne ->vmeta_binop            // Binop call for compatibility.
  |  ldr TAB:CARG1w, [BASE, RC]
  |  b ->BC_LEN_Z
#else
  |  b ->vmeta_binop            // Binop call for compatibility.
#endif
  |
  |//-- Call metamethod ----------------------------------------------------
  |
  |->vmeta_call:            // Resolve and call __call metamethod.
  |  // RB = old base, BASE = new base, RC = nargs*8
  |  mov CARG1, L
  |   str RB, L->base            // This is the callers base!
  |  sub CARG2, BASE, #8
  |   str PCw, SAVE_PC
  |  add CARG3, BASE, NARGS8:RC
  |  bl extern lj_meta_call    // (lua_State *L, TValue *func, TValue *top)
  |  ldr LFUNC:CARG3w, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  |   add NARGS8:RC, NARGS8:RC, #8    // Got one more argument now.
  |  ins_call
  |
  |->vmeta_callt:            // Resolve __call for BC_CALLT.
  |  // BASE = old base, RA = new base, RC = nargs*8
  |  mov CARG1, L
  |   str BASE, L->base
  |  sub CARG2, RA, #8
  |   str PCw, SAVE_PC
  |  add CARG3, RA, NARGS8:RC
  |  bl extern lj_meta_call    // (lua_State *L, TValue *func, TValue *top)
  |  ldr LFUNC:CARG3w, [RA, FRAME_FUNC]  // Guaranteed to be a function here.
  |   ldr PCw, [BASE, FRAME_PC]
  |    add NARGS8:RC, NARGS8:RC, #8    // Got one more argument now.
  |  b ->BC_CALLT2_Z
  |
  |//-- Argument coercion for 'for' statement ------------------------------
  |
  |->vmeta_for:
  |  mov CARG1, L
  |   str BASE, L->base
  |  mov CARG2, RA
  |   str PCw, SAVE_PC
  |  bl extern lj_meta_for    // (lua_State *L, TValue *base)
  |.if JIT
  |   ldrb OPw, [PC, #-4]
  |.endif
  |  ldr INSw, [PC, #-4]
  |.if JIT
  |   cmp OPw, #BC_JFORI
  |.endif
  |  decode_RA8 RAw, INSw
  |  decode_RD RCw, INSw
  |.if JIT
  |   b.eq =>BC_JFORI
  |.endif
  |  b =>BC_FORI
  |
  |//-----------------------------------------------------------------------
  |//-- Fast functions -----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |.macro .ffunc, name
  |->ff_ .. name:
  |.endmacro
  |
  |.macro .ffunc_1, name
  |->ff_ .. name:
  |  ldp CARG1w, CARG2w, [BASE]
  |   cmp NARGS8:RC, #8
  |   b.lo ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_2, name
  |->ff_ .. name:
  |  ldp CARG1w, CARG2w, [BASE]
  |   ldp CARG3w, CARG4w, [BASE, #8]
  |    cmp NARGS8:RC, #16
  |    b.lo ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_n, name
  |  .ffunc_1 name
  |  checktp CARG2w, LJ_TISNUM
  |  b.hs ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_nn, name
  |  .ffunc_2 name
  |  checktp CARG2w, LJ_TISNUM
  |  ccmn CARG4w, #-LJ_TISNUM, #6, lo     // flags = if lo then cmn else hs(carry set)
  |  b.hs ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_d, name
  |  .ffunc name
  |  ldr CARG2w, [BASE, #4]
  |   cmp NARGS8:RC, #8
  |  ldr d0, [BASE]
  |   b.lo ->fff_fallback
  |  checktp CARG2, LJ_TISNUM
  |  b.hs ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_dd, name
  |  .ffunc name
  |  ldr CARG2w, [BASE, #4]
  |  ldr CARG4w, [BASE, #12]
  |   cmp NARGS8:RC, #16
  |  ld1 {v0.1d, v1.1d}, [BASE]
  |   b.lo ->fff_fallback
  |  checktp CARG2w, LJ_TISNUM
  |  ccmn CARG4w, #-LJ_TISNUM, #6, lo     // nzcv flags = if lo then cmn else hs
  |  b.hs ->fff_fallback
  |.endmacro
  |
  |// Inlined GC threshold check. Caveat: uses CARG1 and CARG2.
  |.macro ffgccheck
  |  ldr CARG1w, [DISPATCH, #DISPATCH_GL(gc.total)]
  |  ldr CARG2w, [DISPATCH, #DISPATCH_GL(gc.threshold)]
  |  cmp CARG1w, CARG2w
  |  b.lt >1
  |  bl ->fff_gcstep
  |1:
  |.endmacro
  |
  |//-- Base library: checks -----------------------------------------------
  |
  |.ffunc_1 assert
  |  checktp CARG2w, LJ_TTRUE
  |  b.hi ->fff_fallback
  |   ldr PCw, [BASE, FRAME_PC]
  |  stp CARG1w, CARG2w, [BASE, #-8]
  |  mov RB, BASE
  |  subs RA, NARGS8:RC, #8
  |   add RC, NARGS8:RC, #8        // Compute (nresults+1)*8.
  |  b.eq ->fff_res            // Done if exactly 1 argument.
  |1:
  |   ldr CARG1, [RB, #8]      // load 8 bytes
  |  subs RA, RA, #8
  |   str CARG1, [RB], #8      // store 8 bytes
  |  b.ne <1
  |  b ->fff_res
  |
  |.ffunc type
  |  ldr CARG2w, [BASE, #4]
  |   cmp NARGS8:RC, #8
  |   b.lo ->fff_fallback
  |  checktp CARG2w, LJ_TISNUM
  |  mov CARG1w, #LJ_TISNUM
  |  csel CARG2w, CARG1w, CARG2w, lo
  |  mov CARG4w, #(int)(offsetof(GCfuncC, upvalue)>>3)-1
  |  sub CARG4w, CARG4w, CARG2w
  |  ldr CARG1, [CFUNC:CARG3, CARG4, lsl #3]
  |  bfxil CARG2, CARG1, 32, 32
  |  b ->fff_restv
  |
  |//-- Base library: getters and setters ---------------------------------
  |
  |.ffunc_1 getmetatable
  |  checktp CARG2w, LJ_TTAB
  |  ccmn CARG2w, #-LJ_TUDATA, #6, ne
  |  b.ne >6
  |1:  // Field metatable must be at same offset for GCtab and GCudata!
  |  ldr TAB:RBw, TAB:CARG1->metatable
  |2:
  |   mov CARG2w, #LJ_TNIL
  |   ldr STR:RCw, [DISPATCH, #DISPATCH_GL(gcroot[GCROOT_MMNAME+MM_metatable])]
  |  cbz TAB:RBw, ->fff_restv
  |  ldr CARG3w, TAB:RB->hmask
  |   ldr CARG4w, STR:RC->hash
  |    ldr NODE:INSw, TAB:RB->node
  |  and CARG3w, CARG3w, CARG4w        // idx = str->hash & tab->hmask
  |  add CARG3w, CARG3w, CARG3w, lsl #1
  |    add NODE:INSw, NODE:INSw, CARG3w, lsl #3    // node = tab->node + idx*3*8
  |3:  // Rearranged logic, because we expect _not_ to find the key.
  |  ldp CARG3w, CARG4w, NODE:INS->key  // STALL: early NODE:INS.
  |   ldp CARG1w, CARG2w, NODE:INS->val
  |    ldr NODE:INSw, NODE:INS->next
  |  checktp CARG4w, LJ_TSTR
  |  ccmp CARG3w, STR:RCw, #0, eq
  |  b.eq >5
  |  cbnz NODE:INSw, <3
  |4:
  |  mov CARG1, RB            // Use metatable as default result.
  |  mov CARG2w, #LJ_TTAB
  |  b ->fff_restv
  |5:
  |  checktp CARG2w, LJ_TNIL
  |  b.ne ->fff_restv
  |  b <4
  |
  |6:
  |  checktp CARG2w, LJ_TISNUM
  |  mov CARG4w, #~LJ_TISNUM
  |  csinv CARG2w, CARG4w, CARG2w, lo
  |  add CARG4, DISPATCH, CARG2, lsl #2    // here CARG2 is the index in gcroot, element is GCRef, 4 bytes for arm64
  |  ldr TAB:RBw, [CARG4, #DISPATCH_GL(gcroot[GCROOT_BASEMT])]
  |  b <2
  |
  |.ffunc_2 setmetatable
  |  // Fast path: no mt for table yet and not clearing the mt.
  |  checktp CARG2w, LJ_TTAB
  |  b.ne ->fff_fallback
  |  ldr TAB:RBw, TAB:CARG1->metatable
  |  checktp CARG4w, LJ_TTAB
  |  b.ne ->fff_fallback
  |  ldrb CARG4w, TAB:CARG1->marked
  |  cbnz TAB:RBw, ->fff_fallback
  |    tst CARG4w, #LJ_GC_BLACK        // isblack(table)
  |     str TAB:CARG3w, TAB:CARG1->metatable
  |    b.eq ->fff_restv
  |  barrierback TAB:CARG1w, CARG4w, CARG3w
  |  b ->fff_restv
  |
  |.ffunc rawget
  |  ldp CARG3w, CARG4W, [BASE]
  |   cmp NARGS8:RCw, #16
  |   b.lo ->fff_fallback
  |   mov CARG2w, CARG3w
  |  checktab CARG4w, ->fff_fallback
  |   mov CARG1, L
  |   add CARG3, BASE, #8
  |  bl extern lj_tab_get  // (lua_State *L, GCtab *t, cTValue *key)
  |  // Returns cTValue *.
  |  ldp CARG1w, CARG2w, [CRET1]
  |  b ->fff_restv
  |
  |//-- Base library: conversions ------------------------------------------
  |
  |.ffunc tonumber
  |  // Only handles the number case inline (without a base argument).
  |  ldp CARG1w, CARG2w, [BASE]
  |   cmp NARGS8:RC, #8
  |   b.ne ->fff_fallback
  |  checktp CARG2w, LJ_TISNUM
  |  b.ls ->fff_restv
  |  b ->fff_fallback
  |
  |.ffunc_1 tostring
  |  // Only handles the string or number case inline.
  |  checktp CARG2w, LJ_TSTR
  |  // A __tostring method in the string base metatable is ignored.
  |  b.eq ->fff_restv
  |  // Handle numbers inline, unless a number base metatable is present.
  |  ldr CARG4w, [DISPATCH, #DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM])]
  |   str BASE, L->base
  |  checktp CARG2w, LJ_TISNUM
  |  ccmp CARG4w, #0, #2, ls
  |   str PCw, SAVE_PC            // Redundant (but a defined value).
  |  b.hi ->fff_fallback
  |  ffgccheck
  |  mov CARG1, L
  |  mov CARG2, BASE
  |  bl extern lj_strfmt_number        // (lua_State *L, cTValue *o)
  |  // Returns GCstr *.
  |  ldr BASE, L->base
  |  mov CARG2w, #LJ_TSTR
  |  b ->fff_restv
  |
  |//-- Base library: iterators -------------------------------------------
  |
  |.ffunc_1 next
  |   mov CARG4w, #LJ_TNIL
  |  checktab CARG2w, ->fff_fallback
  |   stp CARG3w, CARG4w, [BASE, NARGS8:RC]    // Set missing 2nd arg to nil.
  |   ldr PCw, [BASE, FRAME_PC]
  |  mov CARG2, CARG1
  |    str BASE, L->base        // Add frame since C call can throw.
  |  mov CARG1, L
  |    str BASE, L->top            // Dummy frame length is ok.
  |  add CARG3, BASE, #8
  |   str PCw, SAVE_PC
  |  bl extern lj_tab_next    // (lua_State *L, GCtab *t, TValue *key)
  |  // Returns 0 at end of traversal.
  |  cmp CRET1, #0
  |  b.ne >1
  |  mov CRET2, #LJ_TNIL
  |  b ->fff_restv            // End of traversal: return nil.
  |1:
  |  ldp CARG1, CARG2, [BASE, #8]        // Copy key and value to results.(16bytes)
  |    mov RC, #(2+1)*8
  |  stp CARG1, CARG2, [BASE, #-8]       // store 16 bytes
  |  b ->fff_res
  |
  |.ffunc_1 pairs
  |  checktab CARG2w, ->fff_fallback
#if LJ_52
  |  ldr TAB:RBw, TAB:CARG1->metatable
#endif
  |   ldr CFUNC:CARG3, CFUNC:CARG3->upvalue[0]     // 8 bytes
  |    ldr PCw, [BASE, FRAME_PC]
#if LJ_52
  |  cbnz TAB:RBw, ->fff_fallback
#endif
  |  mov CARG2w, #LJ_TNIL
  |    mov RC, #(3+1)*8
  |   str CFUNC:CARG3, [BASE, #-8]                 // 8 bytes
  |  str CARG2w, [BASE, #12]
  |  b ->fff_res
  |
  |.ffunc_2 ipairs_aux
  |  checktp CARG2w, LJ_TTAB
  |  b.ne ->fff_fallback
  |  checktp CARG4w, LJ_TISNUM
  |  b.ne ->fff_fallback
  |  ldr RBw, TAB:CARG1->asize
  |   ldr RCw, TAB:CARG1->array
  |  add CARG3, CARG3, #1
  |    ldr PCw, [BASE, FRAME_PC]
  |  cmp CARG3, RB
  |   add CARG8, RC, CARG3, lsl #3
  |   mov RC, #(0+1)*8
  |  stp CARG3w, CARG4w, [BASE, #-8]
  |  b.hs >2                // Not in array part?
  |   ldp CARG1w, CARG2w, [CARG8]
  |1:
  |   checktp CARG2w, LJ_TNIL
  |   b.eq ->fff_res
  |   mov RC, #(2+1)*8
  |   stp CARG1w, CARG2w, [BASE]
  |  b ->fff_res
  |2:  // Check for empty hash part first. Otherwise call C function.
  |  ldr RBw, TAB:CARG1->hmask
  |   mov CARG2, CARG3
  |  cbz RBw, ->fff_res
  |  bl extern lj_tab_getinth        // (GCtab *t, int32_t key)
  |  // Returns cTValue * or NULL.
  |  cbz CRET1, ->fff_res
  |  ldp CARG1w, CARG2w, [CRET1]
  |  b <1
  |
  |.ffunc_1 ipairs
  |  checktab CARG2w, ->fff_fallback
#if LJ_52
  |  ldr TAB:RBw, TAB:CARG1->metatable
#endif
  |   ldr CFUNC:CARG3, CFUNC:CARG3->upvalue[0]       // 8 bytes
  |    ldr PCw, [BASE, FRAME_PC]
#if LJ_52
  |  cbnz TAB:RBw, ->fff_fallback
#endif
  |  mov CARG1w, #0
  |  mov CARG2w, #LJ_TISNUM
  |    mov RC, #(3+1)*8
  |   str CFUNC:CARG3, [BASE, #-8]
  |  stp CARG1w, CARG2w, [BASE, #8]
  |  b ->fff_res
  |
  |//-- Base library: catch errors ----------------------------------------
  |
  |.ffunc pcall
  |  ldrb RAw, [DISPATCH, #DISPATCH_GL(hookmask)]
  |   cmp NARGS8:RCw, #8
  |   b.lo ->fff_fallback
  |  tst RAw, #HOOK_ACTIVE        // Remember active hook before pcall.
  |   mov RB, BASE
  |   add BASE, BASE, #8
  |  mov PCw, #8+FRAME_PCALL
  |  cinc PCw, PCw, ne            // PCw = #8+FRAME_PCALLH (PCALLH=PCALL+1)
  |   sub NARGS8:RC, NARGS8:RC, #8
  |  b ->vm_call_dispatch
  |
  |.ffunc_2 xpcall
  |  ldrb RAw, [DISPATCH, #DISPATCH_GL(hookmask)]
  |  checkfunc CARG4w, ->fff_fallback    // Traceback must be a function.
  |   mov RB, BASE
  |  stp CARG1w, CARG2w, [BASE, #8]        // Swap function and traceback.
  |   stp CARG3w, CARG4w, [BASE]
  |  tst RAw, #HOOK_ACTIVE        // Remember active hook before pcall.
  |   add BASE, BASE, #16
  |  mov PCw, #16+FRAME_PCALL
  |  cinc PCw, PCw, ne            // PCw = #16+FRAME_PCALLH (PCALLH=PCALL+1)
  |   sub NARGS8:RC, NARGS8:RC, #16
  |  b ->vm_call_dispatch
  |
  |//-- Coroutine library --------------------------------------------------
  |
  |.macro coroutine_resume_wrap, resume
  |.if resume
  |.ffunc_1 coroutine_resume
  |  checktp CARG2w, LJ_TTHREAD
  |  b.ne ->fff_fallback
  |.else
  |.ffunc coroutine_wrap_aux
  |  ldr L:CARG1w, CFUNC:CARG3->upvalue[0].gcr
  |.endif
  |   ldr PCw, [BASE, FRAME_PC]
  |     str BASE, L->base
  |  ldr CARG2, L:CARG1->top
  |   ldrb RAw, L:CARG1->status
  |    ldr RB, L:CARG1->base
  |  add CARG3, CARG2, NARGS8:RC
  |  add CARG4, CARG2, RA
  |   str PCw, SAVE_PC
  |  cmp CARG4, RB
  |  b.eq ->fff_fallback
  |   ldr CARG4w, L:CARG1->maxstack
  |    ldr RB, L:CARG1->cframe
  |   cmp RAw, #LUA_YIELD
  |   ccmp CARG3w, CARG4w, #2, ls
  |    ccmp RB, #0, #2, ls
  |    b.hi ->fff_fallback
  |1:
  |.if resume
  |  sub CARG3, CARG3, #8        // Keep resumed thread in stack for GC.
  |  add BASE, BASE, #8
  |  sub NARGS8:RC, NARGS8:RC, #8
  |.endif
  |  str CARG3, L:CARG1->top
  |  str BASE, L->top
  |2:  // Move args to coroutine.
  |  cmp RB, NARGS8:RC
  |   ldr CARG3, [BASE, RB]         // 8 bytes
  |  add RB, RB, #8
  |  b.eq >3
  |  str CARG3, [CARG2, RB]
  |  b <2
  |3:
  |
  |  mov CARG3w, #0
  |   mov L:RA, L:CARG1
  |  mov CARG4w, #0
  |  bl ->vm_resume            // (lua_State *L, TValue *base, 0, 0)
  |  // Returns thread status.
  |4:
  |  ldr CARG3, L:RA->base
  |    mv_vmstate CARG2w, INTERP
  |  ldr CARG4, L:RA->top
  |   cmp CRET1w, #LUA_YIELD
  |  ldr BASE, L->base
  |    str Lw, [DISPATCH, #DISPATCH_GL(cur_L)]
  |    st_vmstate CARG2w
  |   b.hi >8
  |  subs RC, CARG4, CARG3
  |   ldr CARG1w, L->maxstack
  |   add CARG2, BASE, RC
  |  b.eq >6                // No results?
  |  cmp CARG2, CARG1
  |   mov RB, #0
  |  b.hi >9                // Need to grow stack?
  |
  |  sub CARG4, RC, #8
  |   str CARG3, L:RA->top        // Clear coroutine stack.
  |5:  // Move results from coroutine.
  |   ldr CARG1, [CARG3, RB]
  |  cmp RB, CARG4
  |   str CARG1, [BASE, RB]
  |  add RB, RB, #8
  |  b.ne <5
  |6:
  |.if resume
  |  mov CARG3w, #LJ_TTRUE
  |   add RC, RC, #16
  |7:
  |  str CARG3w, [BASE, #-4]        // Prepend true/false to results.
  |   sub RA, BASE, #8
  |.else
  |   mov RA, BASE
  |   add RC, RC, #8
  |.endif
  |  ands CARG1w, PCw, #FRAME_TYPE
  |   str PCw, SAVE_PC
  |   str RCw, SAVE_MULTRES
  |  b.eq ->BC_RET_Z
  |  b ->vm_return
  |
  |8:  // Coroutine returned with error (at co->top-1).
  |.if resume
  |  ldr CARG1, [CARG4, #-8]!
  |   mov CARG3w, #LJ_TFALSE
  |    mov RC, #(2+1)*8
  |  str CARG4, L:RA->top        // Remove error from coroutine stack.
  |  str CARG1, [BASE]        // Copy error message.
  |  b <7
  |.else
  |  mov CARG1, L
  |  mov CARG2, L:RA
  |  bl extern lj_ffh_coroutine_wrap_err  // (lua_State *L, lua_State *co)
  |  // Never returns.
  |.endif
  |
  |9:  // Handle stack expansion on return from yield.
  |  mov CARG1, L
  |  lsr CARG2, RC, #3
  |  bl extern lj_state_growstack    // (lua_State *L, int n)
  |  mov CRET1, #0
  |  b <4
  |.endmacro
  |
  |  coroutine_resume_wrap 1        // coroutine.resume
  |  coroutine_resume_wrap 0        // coroutine.wrap
  |
  |.ffunc coroutine_yield
  |  ldr CARG1, L->cframe
  |   add CARG2, BASE, NARGS8:RC
  |   str BASE, L->base
  |  tst CARG1, #CFRAME_RESUME
  |   str CARG2, L->top
  |    mov CRET1w, #LUA_YIELD
  |   mov CARG3, #0
  |  b.eq ->fff_fallback
  |   str CARG3, L->cframe
  |    strb CRET1w, L->status
  |  b ->vm_leave_unw
  |
  |//-- Math library -------------------------------------------------------
  |
  |.macro math_round, func
  |  .ffunc_1 math_ .. func
  |  checktp CARG2w, LJ_TISNUM
  |  b.eq ->fff_restv
  |  b.hi ->fff_fallback
  |  // Round FP value and normalize result.
  |  lsl CARG3, CARG2, #1
  |  adds RB, CARG3, #0x200, lsl 12
  |  b.pl >2                // |x| < 1?
  |  movn CARG4w, #0x3e0
  |    subs RBw, CARG4w, RBw, asr #21
  |  lsl CARG4w, CARG2w, #11
  |   lsl CARG3w, CARG1w, #11
  |  orr CARG4w, CARG4w, #0x80000000
  |   sub CARG5w, RBw, #32
  |   neg CARG5w, CARG5w
  |  orr CARG4w, CARG4w, CARG1w, lsr #21
  |    b.ls >3                // |x| >= 2^31?
  |   lsl CARG4w, CARG4w, CARG5w
  |   orr CARG3w, CARG3w, CARG4w
  |  lsr CARG1w, CARG4w, RBw
  |.if "func" == "floor"
  |   tst CARG3w, CARG2w, asr #31
  |   cinc CARG1w, CARG1w, ne
  |.else
  |   mvn CARG2w, CARG2w, asr #31
  |   ands CARG3w, CARG3w, CARG2w
  |   b.eq >1
  |   adds CARG1w, CARG1w, #1
  |1:
  |   b.vc >1
  |   ldp CARG1w, CARG2w, >9
  |   b ->fff_restv
  |1:
  |.endif
  |    cmp CARG2w, #0
  |    cneg CARG1w, CARG2w, lt
  |1:
  |   mov CARG2w, #LJ_TISNUM
  |  b ->fff_restv
  |
  |2:  // |x| < 1
  |  b.cs ->fff_restv            // |x| is not finite.
  |  orr CARG3w, CARG3w, CARG1w        // ztest = abs(hi) | lo
  |.if "func" == "floor"
  |  tst CARG3w, CARG2w, asr #31        // return (ztest & sign) == 0 ? 0 : -1
  |  csetm CARG1w, ne
  |.else
  |  mvn CARG2w, CARG2w, asr #31
  |  ands CARG3w, CARG3w, CARG2w        // return (ztest & ~sign) == 0 ? 0 : 1
  |  cset CARG1w, ne
  |.endif
  |  mov CARG2w, #LJ_TISNUM
  |  b ->fff_restv
  |
  |3:  // |x| >= 2^31. Check for x == -(2^31).
  |  ccmp CARG4w, #0x80000000, #0, eq
  |.if "func" == "floor"
  |  ccmp CARG3w, #0, #0, eq
  |.endif
  |  b.ne >4
  |  cmp CARG2w, #0
  |  b.pl >4
  |  mov CARG1, #0x80000000
  |  b <1
  |4:
  |  bl ->vm_..func.._sf
  |  b ->fff_restv
  |.endmacro
  |
  |  math_round floor
  |  math_round ceil
  |
  |.align 8
  |9:
  |  .long 0x00000000, 0x41e00000    // 2^31.
  |
  |.ffunc_1 math_abs
  |  checktp CARG2w, LJ_TISNUM
  |  b.hi ->fff_fallback
  |  b.eq >1
  |  and CARG2w, CARG2w, #~0x80000000
  |  b ->fff_restv
  |1:
  |  cmp CARG1, #0
  |  b.ge >1
  |  negs CARG1w, CARG1w
  |1:
  |  b.vc >1
  |  ldp CARG1w, CARG2w, <9
  |1:
  |  // Fallthrough.
  |
  |->fff_restv:
  |  // CARG12 = TValue result.
  |  ldr PCw, [BASE, FRAME_PC]
  |  stp CARG1w, CARG2w, [BASE, #-8]
  |->fff_res1:
  |  // PC = return.
  |  mov RC, #(1+1)*8
  |->fff_res:
  |  // RC = (nresults+1)*8, PC = return.
  |  ands CARG1, PC, #FRAME_TYPE
  |  b.ne >1
  |  ldr INSw, [PC, #-4]
  |1:
  |   str RCw, SAVE_MULTRES
  |  sub RA, BASE, #8
  |  b.ne ->vm_return
  |  decode_RB8 RBw, INSw
  |5:
  |  cmp RB, RC                // More results expected?
  |  b.hi >6
  |  decode_RA8 CARG1w, INSw
  |   ins_next1
  |   ins_next2
  |  // Adjust BASE. KBASE is assumed to be set for the calling frame.
  |  sub BASE, RA, CARG1
  |   ins_next3
  |
  |6:  // Fill up results with nil.
  |  add CARG2, RA, RC
  |  mov CARG1w, #LJ_TNIL
  |   add RC, RC, #8
  |  str CARG1w, [CARG2, #-4]
  |  b <5
  |
  |.macro math_extern, func
  |.if HFABI
  |  .ffunc_d math_ .. func
  |.else
  |  .ffunc_n math_ .. func
  |.endif
  |  bl extern func
  |.if HFABI
  |  b ->fff_resd
  |.else
  |  b ->fff_restv
  |.endif
  |.endmacro
  |
  |.macro math_extern2, func
  |.if HFABI
  |  .ffunc_dd math_ .. func
  |.else
  |  .ffunc_nn math_ .. func
  |.endif
  |  bl extern func
  |.if HFABI
  |  b ->fff_resd
  |.else
  |  b ->fff_restv
  |.endif
  |.endmacro
  |
  |.if FPU
  |  .ffunc_d math_sqrt
  |  fsqrt d0, d0
  |->fff_resd:
  |  ldr PCw, [BASE, FRAME_PC]
  |  str d0, [BASE, #-8]
  |  b ->fff_res1
  |.else
  |  math_extern sqrt
  |.endif
  |
  |.ffunc math_log
  |.if HFABI
  |  ldr CARG2, [BASE, #4]
  |   cmp NARGS8:RC, #8            // Need exactly 1 argument.
  |  ldr d0, [BASE]
  |   b.ne ->fff_fallback
  |.else
  |  ldp CARG1w, CARG2w, [BASE]
  |   cmp NARGS8:RC, #8            // Need exactly 1 argument.
  |   b.ne ->fff_fallback
  |.endif
  |  checktp CARG2w, LJ_TISNUM
  |  b.hs ->fff_fallback
  |  bl extern log
  |.if HFABI
  |  b ->fff_resd
  |.else
  |  b ->fff_restv
  |.endif
  |
  |  math_extern log10
  |  math_extern exp
  |  math_extern sin
  |  math_extern cos
  |  math_extern tan
  |  math_extern asin
  |  math_extern acos
  |  math_extern atan
  |  math_extern sinh
  |  math_extern cosh
  |  math_extern tanh
  |  math_extern2 pow
  |  math_extern2 atan2
  |  math_extern2 fmod
  |
  |.if HFABI
  |  .ffunc math_ldexp
  |  ldr CARG4w, [BASE, #4]
  |  ldp CARG1w, CARG2w, [BASE, #8]
  |   cmp NARGS8:RC, #16
  |   b.lo ->fff_fallback
  |  ldr d0, [BASE]
  |  checktp CARG4w, LJ_TISNUM
  |  b.hs ->fff_fallback
  |  checktp CARG2w, LJ_TISNUM
  |  b.ne ->fff_fallback
  |  bl extern ldexp            // (double x, int exp)
  |  b ->fff_resd
  |.else
  |.ffunc_2 math_ldexp
  |  checktp CARG2w, LJ_TISNUM
  |  b.hs ->fff_fallback
  |  checktp CARG4w, LJ_TISNUM
  |  b.ne ->fff_fallback
  |  bl extern ldexp            // (double x, int exp)
  |  b ->fff_restv
  |.endif
  |
  |.if HFABI
  |.ffunc_d math_frexp
  |  mov CARG1, sp
  |  bl extern frexp
  |   ldr CARG3w, [sp]
  |   mov CARG4w, #LJ_TISNUM
  |    ldr PCw, [BASE, FRAME_PC]
  |  str d0, [BASE, #-8]
  |    mov RC, #(2+1)*8
  |   stp CARG3w, CARG4w, [BASE]
  |  b ->fff_res
  |.else
  |.ffunc_n math_frexp
  |  mov CARG3, sp
  |  bl extern frexp
  |   ldr CARG3w, [sp]
  |   mov CARG4w, #LJ_TISNUM
  |    ldr PCw, [BASE, FRAME_PC]
  |  stp CARG1w, CARG2w, [BASE, #-8]
  |    mov RC, #(2+1)*8
  |   stp CARG3w, CARG4w, [BASE]
  |  b ->fff_res
  |.endif
  |
  |.if HFABI
  |.ffunc_d math_modf
  |  sub CARG1, BASE, #8
  |   ldr PCw, [BASE, FRAME_PC]
  |  bl extern modf
  |   mov RC, #(2+1)*8
  |  str d0, [BASE]
  |  b ->fff_res
  |.else
  |.ffunc_n math_modf
  |  sub CARG3, BASE, #8
  |   ldr PCw, [BASE, FRAME_PC]
  |  bl extern modf
  |   mov RC, #(2+1)*8
  |  stp CARG1w, CARG2w, [BASE]
  |  b ->fff_res
  |.endif
  |
  |.macro math_minmax, name, cond, fcond
  |.if FPU
  |  .ffunc_1 name
  |   add RB, BASE, RC
  |  checktp CARG2w, LJ_TISNUM
  |   add RA, BASE, #8
  |  b.ne >4
  |1:  // Handle integers.
  |  ldp CARG3w, CARG4w, [RA]
  |   cmp RA, RB
  |   b.hs ->fff_restv
  |  checktp CARG4w, LJ_TISNUM
  |  b.ne >3
  |  cmp CARG1, CARG3
  |   add RA, RA, #8
  |  csel CARG1, CARG3, CARG1, cond
  |  b <1
  |3:  // Convert intermediate result to number and continue below.
  |  fmov s4, CARG1w
  |  b.hi ->fff_fallback
  |  ldr d1, [RA]
  |  fcvt d0, s4
  |  b >6
  |
  |4:
  |  ldr d0, [BASE]
  |  b.hi ->fff_fallback
  |5:  // Handle numbers.
  |  ldp CARG3w, CARG4w, [RA]
  |  ldr d1, [RA]
  |   cmp RA, RB
  |   b.hs ->fff_resd
  |  checktp CARG4w, LJ_TISNUM
  |  b.hs >7
  |6:
  |  fcmp d0, d1
  |   add RA, RA, #8
  |  fcsel d0, d1, d0, fcond
  |  b <5
  |7:  // Convert integer to number and continue above.
  |  fmov s4, CARG3w
  |  b.hi ->fff_fallback
  |  fcvt d1, s4
  |  b <6
  |
  |.else
  |
  |  .ffunc_1 name
  |  checktp CARG2w, LJ_TISNUM
  |   mov RA, #8
  |  b.ne >4
  |1:  // Handle integers.
  |  ldp CARG3w, CARG4w, [BASE, RA]
  |   cmp RA, RC
  |   b.hs ->fff_restv
  |  checktp CARG4w, LJ_TISNUM
  |  b.ne >3
  |  cmp CARG1, CARG3
  |   add RA, RA, #8
  |  csel CARG1, CARG3, CARG1, cond
  |  b <1
  |3:  // Convert intermediate result to number and continue below.
  |  b.hi ->fff_fallback
  |  bl extern __aeabi_i2d
  |  ldp CARG3w, CARG4w, [BASE, RA]
  |  b >6
  |
  |4:
  |  b.hi ->fff_fallback
  |5:  // Handle numbers.
  |  ldp CARG3w, CARG4w, [BASE, RA]
  |   cmp RA, RC
  |   b.hs ->fff_restv
  |  checktp CARG4w, LJ_TISNUM
  |  b.hs >7
  |6:
  |  bl extern __aeabi_cdcmple
  |   add RA, RA, #8
  |  csel CARG1, CARG3, CARG1, fcond
  |  csel CARG2, CARG4, CARG2, fcond
  |  b <5
  |7:  // Convert integer to number and continue above.
  |  b.hi ->fff_fallback
  |  stp CARG1w, CARG2w, TMPD
  |  mov CARG1, CARG3
  |  bl extern __aeabi_i2d
  |  ldp CARG3w, CARG4w, TMPD
  |  b <6
  |.endif
  |.endmacro
  |
  |  math_minmax math_min, gt, hi
  |  math_minmax math_max, lt, lo
  |
  |//-- String library -----------------------------------------------------
  |
  |.ffunc string_byte            // Only handle the 1-arg case here.
  |  ldp CARG1w, CARG2w, [BASE]
  |    ldr PCw, [BASE, FRAME_PC]
  |   cmp NARGS8:RC, #8
  |   checktpeq CARG2w, LJ_TSTR        // Need exactly 1 argument.
  |   b.ne ->fff_fallback
  |  ldr CARG3w, STR:CARG1->len
  |   ldrb CARG1w, STR:CARG1[1]        // Access is always ok (NUL at end).
  |   mov CARG2w, #LJ_TISNUM
  |  cmp CARG3w, #0
  |  mov RC, #(0+1)*8
  |  mov CARG5, #(1+1)*8
  |  csel RC, RC, CARG5, eq
  |   stp CARG1w, CARG2w, [BASE, #-8]
  |  b ->fff_res
  |
  |.ffunc string_char            // Only handle the 1-arg case here.
  |  ffgccheck
  |  ldp CARG1w, CARG2w, [BASE]
  |    ldr PCw, [BASE, FRAME_PC]
  |   cmp NARGS8:RC, #8            // Need exactly 1 argument.
  |   checktpeq CARG2w, LJ_TISNUM
  |   b.ne >1
  |   ands CARG4w, CARG1w, #~255u
  |1:
  |  mov CARG3, #1
  |   b.ne ->fff_fallback
  |  str CARG1w, TMPD
  |  mov CARG2, TMPDp            // Points to stack. Little-endian.
  |->fff_newstr:
  |  // CARG2 = str, CARG3 = len.
  |   str BASE, L->base
  |  mov CARG1, L
  |   str PCw, SAVE_PC
  |  bl extern lj_str_new        // (lua_State *L, char *str, size_t l)
  |->fff_resstr:
  |  // Returns GCstr *.
  |  ldr BASE, L->base
  |   mov CARG2w, #LJ_TSTR
  |  b ->fff_restv
  |
  |.ffunc string_sub
  |  ffgccheck
  |  ldp CARG1w, CARG2w, [BASE]
  |   ldp CARG3w, CARG4w, [BASE, #16]
  |    cmp NARGS8:RC, #16
  |     mov RB, #~0u
  |    b.eq >1
  |    b.lo ->fff_fallback
  |   checktp CARG4w, LJ_TISNUM
  |    mov RB, CARG3
  |   b.ne ->fff_fallback
  |1:
  |  ldp CARG3w, CARG4w, [BASE, #8]
  |  checktp CARG2w, LJ_TSTR
  |  b.ne ->fff_fallback
  |   ldr CARG2w, STR:CARG1->len
  |  checktp CARG4w, LJ_TISNUM
  |  b.ne ->fff_fallback
  |  // CARG1 = str, CARG2 = str->len, CARG3 = start, RB = end
  |  add CARG4, CARG2, #1
  |  cmp CARG3, #0            // if (start < 0) start += len+1
  |  add CARG5, CARG3, CARG4
  |  csel CARG3, CARG5, CARG3, lt
  |  mov CARG5, #1
  |  cmp CARG3, #1            // if (start < 1) start = 1
  |  csel CARG3, CARG5, CARG3, lt
  |  cmp RB, #0                // if (end < 0) end += len+1
  |  add CARG5, RB, CARG4
  |  csel RB, CARG5, RB, lt
  |  cmp RB, #0
  |  csel RB, xzr, RB, lt      // if (end < 0) end = 0
  |  cmp RB, CARG2            // if (end > len) end = len
  |   add CARG1, STR:CARG1, #sizeof(GCstr)-1
  |  csel RB, CARG2, RB, gt
  |   add CARG2, CARG1, CARG3
  |  subs CARG3, RB, CARG3        // len = end - start
  |   add CARG3, CARG3, #1        // len += 1
  |  b.ge ->fff_newstr
  |->fff_emptystr:
  |  sub STR:CARG1, DISPATCH, #-DISPATCH_GL(strempty)
  |  mov CARG2, #LJ_TSTR
  |  b ->fff_restv
  |
  |.macro ffstring_op, name
  |  .ffunc string_ .. name
  |  ffgccheck
  |  ldr CARG3w, [BASE, #4]
  |   cmp NARGS8:RC, #8
  |  ldr STR:CARG2w, [BASE]
  |   b.lo ->fff_fallback
  |  sub SBUF:CARG1, DISPATCH, #-DISPATCH_GL(tmpbuf)
  |  checkstr CARG3w, ->fff_fallback
  |  ldr CARG4w, SBUF:CARG1->b
  |   str BASE, L->base
  |   str PCw, SAVE_PC
  |   str Lw, SBUF:CARG1->L
  |  str CARG4w, SBUF:CARG1->p
  |  bl extern lj_buf_putstr_ .. name
  |  bl extern lj_buf_tostr
  |  b ->fff_resstr
  |.endmacro
  |
  |ffstring_op reverse
  |ffstring_op lower
  |ffstring_op upper
  |
  |//-- Bit library --------------------------------------------------------
  |
  |// FP number to bit conversion for soft-float. Clobbers r0-r3.
  |->vm_tobit_fb:
  |  b.hi ->fff_fallback
  |->vm_tobit:
  |  lsl RBw, CARG2w, #1
  |  adds RBw, RBw, #0x00200000
  |  b.mi >1
  |  mov CARG1, #0            // |x| < 1?
  |  ret
  |1:
  |  movn CARG4w, #0x3e0
  |  subs RBw, CARG4w, RBw, asr #21
  |  b.mi >2                // |x| >= 2^32?
  |  lsl CARG4w, CARG2w, #11
  |  orr CARG4w, CARG4w, #0x80000000
  |  orr CARG4w, CARG4w, CARG1w, lsr #21
  |   cmp CARG2w, #0
  |  lsr CARG1w, CARG4w, RBw
  |   cneg CARG1w, CARG1w, lt
  |  ret
  |2:
  |  add RBw, RBw, #21
  |  lsr CARG4w, CARG1w, RBw
  |  sub RBw, RBw, #20
  |  mvn RBw, RBw
  |  lsl CARG1w, CARG2w, #12
  |   cmp CARG2, #0
  |  lsl CARG4w, CARG1w, RBw
  |  orr CARG1w, CARG4w
  |   cneg CARG1w, CARG1w, lt
  |  ret
  |
  |.macro .ffunc_bit, name
  |  .ffunc_1 bit_..name
  |  checktp CARG2w, LJ_TISNUM
  |  b.eq >1
  |  bl ->vm_tobit_fb
  |1:
  |.endmacro
  |
  |.ffunc_bit tobit
  |  mov CARG2w, #LJ_TISNUM
  |  b ->fff_restv
  |
  |.macro .ffunc_bit_op, name, ins
  |  .ffunc_bit name
  |  mov CARG3, CARG1
  |  mov RA, #8
  |1:
  |  ldp CARG1w, CARG2w, [BASE, RA]
  |   cmp RA, NARGS8:RC
  |    add RA, RA, #8
  |   b.ge >3
  |  checktp CARG2w, LJ_TISNUM
  |  b.eq >2
  |  bl ->vm_tobit_fb
  |2:
  |  ins CARG3w, CARG3w, CARG1w
  |  b <1
  |.endmacro
  |
  |.ffunc_bit_op band, and
  |.ffunc_bit_op bor, orr
  |.ffunc_bit_op bxor, eor
  |
  |3:
  |  mov CARG4w, #LJ_TISNUM
  |   ldr PCw, [BASE, FRAME_PC]
  |  stp CARG3w, CARG4w, [BASE, #-8]
  |  b ->fff_res1
  |
  |.ffunc_bit bswap
  |  eor CARG3w, CARG1w, CARG1w, ror #16
  |  and CARG3w, CARG3w, #~0x00ff0000u
  |  ror CARG1w, CARG1w, #8
  |   mov CARG2w, #LJ_TISNUM
  |  eor CARG1w, CARG1w, CARG3w, lsr #8
  |  b ->fff_restv
  |
  |.ffunc_bit bnot
  |  mvn CARG1w, CARG1w
  |  mov CARG2w, #LJ_TISNUM
  |  b ->fff_restv
  |
  |.macro .ffunc_bit_sh, name, ins, shmod
  |  .ffunc bit_..name
  |  ldp CARG1w, CARG2w, [BASE, #8]
  |   cmp NARGS8:RC, #16
  |   b.lo ->fff_fallback
  |  checktp CARG2w, LJ_TISNUM
  |  b.eq >1
  |  bl ->vm_tobit_fb
  |1:
  |.if shmod == 0
  |  and RAw, CARG1w, #31
  |.else
  |  neg RAw, CARG1w
  |.endif
  |  ldp CARG1w, CARG2w, [BASE]
  |  checktp CARG2w, LJ_TISNUM
  |  b.eq >2
  |  bl ->vm_tobit_fb
  |2:
  |  ins CARG1w, CARG1w, RAw
  |  mov CARG2w, #LJ_TISNUM
  |  b ->fff_restv
  |.endmacro
  |
  |.ffunc_bit_sh lshift, lsl, 0
  |.ffunc_bit_sh rshift, lsr, 0
  |.ffunc_bit_sh arshift, asr, 0
  |.ffunc_bit_sh rol, ror, 1
  |.ffunc_bit_sh ror, ror, 0
  |
  |//-----------------------------------------------------------------------
  |
  |->fff_fallback:            // Call fast function fallback handler.
  |  // BASE = new base, RC = nargs*8
  |   ldr CARG3w, [BASE, FRAME_FUNC]
  |  ldr CARG2w, L->maxstack
  |  add CARG1, BASE, NARGS8:RC
  |    ldr PCw, [BASE, FRAME_PC]        // Fallback may overwrite PC.
  |  str CARG1, L->top
  |   ldr CARG3, CFUNC:CARG3->f
  |    str BASE, L->base
  |  add CARG1, CARG1, #8*LUA_MINSTACK
  |    str PCw, SAVE_PC            // Redundant (but a defined value).
  |  cmp CARG1, CARG2
  |   mov CARG1, L
  |  b.hi >5                // Need to grow stack.
  |   blr CARG3                // (lua_State *L)
  |  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
  |   ldr BASE, L->base
  |  cmp CRET1w, #0
  |   lsl RCw, CRET1w, #3
  |   sub RA, BASE, #8
  |  b.gt ->fff_res            // Returned nresults+1?
  |1:  // Returned 0 or -1: retry fast path.
  |   ldr CARG1, L->top
  |    ldr LFUNC:CARG3w, [BASE, FRAME_FUNC]
  |   sub NARGS8:RC, CARG1, BASE
  |  b.ne ->vm_call_tail            // Returned -1?
  |  ins_callt                // Returned 0: retry fast path.
  |
  |// Reconstruct previous base for vmeta_call during tailcall.
  |->vm_call_tail:
  |  ands CARG1w, PCw, #FRAME_TYPE
  |   and CARG2, PC, #~FRAME_TYPEP
  |  b.ne >2
  |  ldr INSw, [PC, #-4]
  |  and CARG2w, MASKR8, INSw, lsr #5    // Conditional decode_RA8.
  |  add CARG2w, CARG2w, #8
  |2:
  |  sub RB, BASE, CARG2
  |  b ->vm_call_dispatch        // Resolve again for tailcall.
  |
  |5:  // Grow stack for fallback handler.
  |  mov CARG2w, #LUA_MINSTACK
  |  bl extern lj_state_growstack    // (lua_State *L, int n)
  |  ldr BASE, L->base
  |  cmp CARG1, CARG1            // Set zero-flag to force retry.
  |  b <1
  |
  |->fff_gcstep:            // Call GC step function.
  |  // BASE = new base, RC = nargs*8
  |  mov RA, lr
  |   str BASE, L->base
  |  add CARG2, BASE, NARGS8:RC
  |   str PCw, SAVE_PC            // Redundant (but a defined value).
  |  str CARG2, L->top
  |  mov CARG1, L
  |  bl extern lj_gc_step        // (lua_State *L)
  |   ldr BASE, L->base
  |  mov lr, RA                // Help return address predictor.
  |   ldr CFUNC:CARG3w, [BASE, FRAME_FUNC]
  |  ret
  |
  |//-----------------------------------------------------------------------
  |//-- Special dispatch targets -------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_record:                // Dispatch target for recording phase.
  |.if JIT
  |  ldrb CARG1w, [DISPATCH, #DISPATCH_GL(hookmask)]
  |  tst CARG1w, #HOOK_VMEVENT        // No recording while in vmevent.
  |  b.ne >5
  |  // Decrement the hookcount for consistency, but always do the call.
  |   ldr CARG2w, [DISPATCH, #DISPATCH_GL(hookcount)]
  |  tst CARG1w, #HOOK_ACTIVE
  |  b.ne >1
  |   sub CARG2w, CARG2w, #1
  |  tst CARG1w, #LUA_MASKLINE|LUA_MASKCOUNT
  |  b.eq >1
  |   str CARG2w, [DISPATCH, #DISPATCH_GL(hookcount)]
  |  b >1
  |.endif
  |
  |->vm_rethook:            // Dispatch target for return hooks.
  |  ldrb CARG1w, [DISPATCH, #DISPATCH_GL(hookmask)]
  |  tst CARG1w, #HOOK_ACTIVE        // Hook already active?
  |  b.eq >1
  |5:  // Re-dispatch to static ins.
  |  decode_OP OPw, INSw
  |  add OP, DISPATCH, OP, lsl #2
  |  ldr ARG5, [OP, #GG_DISP2STATIC]
  |  br ARG5
  |
  |->vm_inshook:            // Dispatch target for instr/line hooks.
  |  ldrb CARG1w, [DISPATCH, #DISPATCH_GL(hookmask)]
  |   ldr CARG2w, [DISPATCH, #DISPATCH_GL(hookcount)]
  |  tst CARG1w, #HOOK_ACTIVE        // Hook already active?
  |  b.ne <5
  |  tst CARG1w, #LUA_MASKLINE|LUA_MASKCOUNT
  |  b.eq <5
  |   subs CARG2w, CARG2w, #1
  |   str CARG2w, [DISPATCH, #DISPATCH_GL(hookcount)]
  |   b.eq >1
  |  tst CARG1w, #LUA_MASKLINE
  |  b.eq <5
  |1:
  |  mov CARG1, L
  |   str BASE, L->base
  |  mov CARG2, PC
  |  // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
  |  bl extern lj_dispatch_ins        // (lua_State *L, const BCIns *pc)
  |3:
  |  ldr BASE, L->base
  |4:  // Re-dispatch to static ins.
  |  ldrb OPw, [PC, #-4]
  |   ldr INSw, [PC, #-4]
  |  add OP, DISPATCH, OP, lsl #2
  |  ldr OP, [OP, #GG_DISP2STATIC]
  |   decode_RA8 RAw, INSw
  |   decode_RD RCw, INSw
  |  br OP
  |
  |->cont_hook:                // Continue from hook yield.
  |  ldr CARG1w, [CARG4, #-24]
  |   add PC, PC, #4
  |  str CARG1w, SAVE_MULTRES        // Restore MULTRES for *M ins.
  |  b <4
  |
  |->vm_hotloop:            // Hot loop counter underflow.
  |.if JIT
  |  ldr LFUNC:CARG3w, [BASE, FRAME_FUNC]  // Same as curr_topL(L).
  |   sub CARG1, DISPATCH, #-GG_DISP2J
  |   str PCw, SAVE_PC
  |  ldr CARG3w, LFUNC:CARG3->field_pc
  |   mov CARG2, PC
  |   str L, [DISPATCH, #DISPATCH_J(L)]
  |  ldrb CARG3w, [CARG3, #PC2PROTO(framesize)]
  |   str BASE, L->base
  |  add CARG3, BASE, CARG3, lsl #3
  |  str CARG3, L->top
  |  bl extern lj_trace_hot        // (jit_State *J, const BCIns *pc)
  |  b <3
  |.endif
  |
  |->vm_callhook:            // Dispatch target for call hooks.
  |  mov CARG2, PC
  |.if JIT
  |  b >1
  |.endif
  |
  |->vm_hotcall:            // Hot call counter underflow.
  |.if JIT
  |  orr CARG2, PC, #1
  |1:
  |.endif
  |  add CARG4, BASE, RC
  |   str PCw, SAVE_PC
  |    mov CARG1, L
  |   str BASE, L->base
  |    sub RA, RA, BASE
  |  str CARG4, L->top
  |  bl extern lj_dispatch_call        // (lua_State *L, const BCIns *pc)
  |  // Returns ASMFunction.
  |  ldr BASE, L->base
  |   ldr CARG4, L->top
  |    mov CARG2, #0
  |  add RA, BASE, RA
  |   sub NARGS8:RC, CARG4, BASE
  |    str CARG2w, SAVE_PC        // Invalidate for subsequent line hook.
  |  ldr LFUNC:CARG3w, [BASE, FRAME_FUNC]
  |   ldr INSw, [PC, #-4]
  |  br CRET1
  |
  |->cont_stitch:            // Trace stitching.
  |.if JIT
  |  // RA = resultptr, CARG4 = meta base
  |   ldr RBw, SAVE_MULTRES
  |  ldr INSw, [PC, #-4]
  |    ldr CARG3w, [CARG4, #-24]        // Save previous trace number.
  |   subs RBw, RBw, #8
  |  decode_RA8 RCw, INSw            // Call base.
  |   b.eq >2
  |1:  // Move results down.
  |  ldr CARG1, [RA]
  |    add RA, RA, #8
  |   subs RB, RB, #8
  |  str CARG1, [BASE, RC]
  |    add RC, RC, #8
  |   b.ne <1
  |2:
  |   decode_RA8 RAw, INSw
  |   decode_RB8 RBw, INSw
  |   add RA, RA, RB
  |  ldr CARG1, [DISPATCH, #DISPATCH_J(trace)]
  |3:
  |   cmp RA, RC
  |  mov CARG2w, #LJ_TNIL
  |   b.hi >9                // More results wanted?
  |
  |  ldr TRACE:RAw, [CARG1, CARG3, lsl #2]
  |  cmp TRACE:RAw, #0
  |  b.eq ->cont_nop
  |  ldrh RCw, TRACE:RA->link
  |  cmp RCw, CARG3w
  |  b.eq ->cont_nop            // Blacklisted.
  |  cmp RC, #0
  |  b.ne =>BC_JLOOP            // Jump to stitched trace.
  |
  |  // Stitch a new trace to the previous trace.
  |  str CARG3w, [DISPATCH, #DISPATCH_J(exitno)]
  |  str L, [DISPATCH, #DISPATCH_J(L)]
  |  str BASE, L->base
  |  sub CARG1, DISPATCH, #-GG_DISP2J
  |  mov CARG2, PC
  |  bl extern lj_dispatch_stitch    // (jit_State *J, const BCIns *pc)
  |  ldr BASE, L->base
  |  b ->cont_nop
  |
  |9:  // Fill up results with nil.
  |  stp CARG1w, CARG2w, [BASE, RC]
  |  add RC, RC, #8
  |  b <3
  |.endif
  |
  |->vm_profhook:            // Dispatch target for profiler hook.
#if LJ_HASPROFILE
  |  mov CARG1, L
  |   str BASE, L->base
  |  mov CARG2, PC
  |  bl extern lj_dispatch_profile    // (lua_State *L, const BCIns *pc)
  |  // HOOK_PROFILE is off again, so re-dispatch to dynamic instruction.
  |  ldr BASE, L->base
  |  sub PC, PC, #4
  |  b ->cont_nop
#endif
  |
  |//-----------------------------------------------------------------------
  |//-- Trace exit handler -------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_exit_handler:
  |.if JIT           //JIT code, do not support for arm64 now
  |  sub sp, sp, #12
  |  push {r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12}
  |  ldr CARG1, [sp, #64]    // Load original value of lr.
  |   ldr DISPATCH, [lr]    // Load DISPATCH.
  |    add CARG3, sp, #64    // Recompute original value of sp.
  |   mv_vmstate CARG4w, EXIT
  |    str CARG3, [sp, #52]    // Store sp in RID_SP
  |   st_vmstate CARG4w
  |  ldr CARG2, [CARG1, #-4]!    // Get exit instruction.
  |   str CARG1, [sp, #56]    // Store exit pc in RID_LR and RID_PC.
  |   str CARG1, [sp, #60]
  |.if FPU
  |  vpush {d0-d15}
  |.endif
  |  lsl CARG2, CARG2, #8
  |  add CARG1, CARG1, CARG2, asr #6
  |   ldr CARG2, [lr, #4]    // Load exit stub group offset.
  |   sub CARG1, CARG1, lr
  |  ldr L, [DISPATCH, #DISPATCH_GL(cur_L)]
  |   add CARG1, CARG2, CARG1, lsr #2    // Compute exit number.
  |    ldr BASE, [DISPATCH, #DISPATCH_GL(jit_base)]
  |   str CARG1, [DISPATCH, #DISPATCH_J(exitno)]
  |   mov CARG4, #0
  |    str BASE, L->base
  |  str L, [DISPATCH, #DISPATCH_J(L)]
  |   str CARG4, [DISPATCH, #DISPATCH_GL(jit_base)]
  |  sub CARG1, DISPATCH, #-GG_DISP2J
  |  mov CARG2, sp
  |  bl extern lj_trace_exit        // (jit_State *J, ExitState *ex)
  |  // Returns MULTRES (unscaled) or negated error code.
  |  ldr CARG2, L->cframe
  |   ldr BASE, L->base
  |  bic CARG2, CARG2, #~CFRAME_RAWMASK    // Use two steps: bic sp is deprecated.
  |  mov sp, CARG2
  |   ldr PC, SAVE_PC            // Get SAVE_PC.
  |  str L, SAVE_L            // Set SAVE_L (on-trace resume/yield).
  |  b >1
  |.endif
  |->vm_exit_interp:
  |  // CARG1 = MULTRES or negated error code, BASE, PC and DISPATCH set.
  |.if JIT           //JIT code, do not support for arm64 now
  |  ldr L, SAVE_L
  |1:
  |  cmp CARG1, #0
  |  blt >9                // Check for error from exit.
  |   lsl RC, CARG1, #3
  |  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
  |   str RC, SAVE_MULTRES
  |   mov CARG3, #0
  |   str BASE, L->base
  |  ldr CARG2, LFUNC:CARG2->field_pc
  |   str CARG3, [DISPATCH, #DISPATCH_GL(jit_base)]
  |    mv_vmstate CARG4w, INTERP
  |  ldr KBASE, [CARG2, #PC2PROTO(k)]
  |  // Modified copy of ins_next which handles function header dispatch, too.
  |  ldrb OP, [PC]
  |     mov MASKR8, #255
  |   ldr INS, [PC], #4
  |     lsl MASKR8, MASKR8, #3        // MASKR8 = 255*8.
  |    st_vmstate CARG4w
  |  cmp OP, #BC_FUNCC+2        // Fast function?
  |  bhs >4
  |2:
  |  cmp OP, #BC_FUNCF            // Function header?
  |  ldr OP, [DISPATCH, OP, lsl #2]
  |   decode_RA8 RA, INS
  |   lsrlo RC, INS, #16    // No: Decode operands A*8 and D.
  |   subhs RC, RC, #8
  |   addhs RA, RA, BASE    // Yes: RA = BASE+framesize*8, RC = nargs*8
  |   ldrhs CARG3, [BASE, FRAME_FUNC]
  |  bx OP
  |
  |4:  // Check frame below fast function.
  |  ldr CARG1, [BASE, FRAME_PC]
  |  ands CARG2, CARG1, #FRAME_TYPE
  |  bne <2            // Trace stitching continuation?
  |  // Otherwise set KBASE for Lua function below fast function.
  |  ldr CARG3, [CARG1, #-4]
  |  decode_RA8 CARG1, CARG3
  |  sub CARG2, BASE, CARG1
  |  ldr LFUNC:CARG3, [CARG2, #-16]
  |  ldr CARG3, LFUNC:CARG3->field_pc
  |  ldr KBASE, [CARG3, #PC2PROTO(k)]
  |  b <2
  |
  |9:  // Rethrow error from the right C frame.
  |  rsb CARG2, CARG1, #0
  |  mov CARG1, L
  |  bl extern lj_err_throw        // (lua_State *L, int errcode)
  |.endif
  |
  |//-----------------------------------------------------------------------
  |//-- Math helper functions ----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |// FP value rounding. Called from JIT code.
  |//
  |// double lj_vm_floor/ceil/trunc(double x);
  |->vm_floor:
  |  frintp d0, d0
  |  ret
  |
  |->vm_ceil:
  |  frintm d0, d0
  |  ret
  |
  |->vm_trunc:
  |.if JIT
  |  frintz d0, d0
  |  ret
  |.endif
  |
  |  // double lj_vm_mod(double dividend, double divisor);
  |->vm_mod:
  |  // Special calling convention. Also, RC (r11) is not preserved.
  |  fdiv d0, d6, d7
  |  frintm d0, d0
  |  fmul d0, d0, d7
  |  fsub d6, d6, d0
  |  ret
  |
  |  // int lj_vm_modi(int dividend, int divisor);
  |->vm_modi:
  |  scvtf d0, CARG1w
  |  scvtf d1, CARG2w
  |  fdiv d2, d0, d1
  |  frintm d2, d2
  |  fmul d2, d1, d2
  |  fsub d0, d0, d2
  |  fcvtzs CRET1w, d0
  |  ret
  |
  |
  |//-----------------------------------------------------------------------
  |//-- Miscellaneous functions --------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |//-----------------------------------------------------------------------
  |//-- FFI helper functions -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |// Handler for callback functions.
  |// Saveregs already performed. Callback slot number in [sp], g in r12.
  |->vm_ffi_callback:
  |.if FFI
  |.type CTSTATE, CTState, PC
  |  ldr CTSTATE, GL:r12->ctype_state
  |   add DISPATCH, r12, #GG_G2DISP
  |.if FPU
  |  str r4, SAVE_R4
  |  add r4, sp, #CFRAME_SPACE+4+8*8
  |  vstmdb r4!, {d8-d15}
  |.endif
  |.if HFABI
  |  add r12, CTSTATE, #offsetof(CTState, cb.fpr[8])
  |.endif
  |  strd CARG34, CTSTATE->cb.gpr[2]
  |  strd CARG12, CTSTATE->cb.gpr[0]
  |.if HFABI
  |  vstmdb r12!, {d0-d7}
  |.endif
  |  ldr CARG4, [sp]
  |   add CARG3, sp, #CFRAME_SIZE
  |    mov CARG1, CTSTATE
  |  lsr CARG4, CARG4, #3
  |   str CARG3, CTSTATE->cb.stack
  |    mov CARG2, sp
  |  str CARG4, CTSTATE->cb.slot
  |  str CTSTATE, SAVE_PC        // Any value outside of bytecode is ok.
  |  bl extern lj_ccallback_enter    // (CTState *cts, void *cf)
  |  // Returns lua_State *.
  |  ldr BASE, L:CRET1->base
  |    mv_vmstate CARG2w, INTERP
  |  ldr RC, L:CRET1->top
  |    mov MASKR8, #255
  |   ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  |    mov L, CRET1
  |  sub RC, RC, BASE
  |    lsl MASKR8, MASKR8, #3        // MASKR8 = 255*8.
  |    st_vmstate CARG2w
  |  ins_callt
  |.endif
  |
  |->cont_ffi_callback:            // Return from FFI callback.
  |.if FFI
  |  ldr CTSTATE, [DISPATCH, #DISPATCH_GL(ctype_state)]
  |   str BASE, L->base
  |   str CARG4, L->top
  |  str L, CTSTATE->L
  |  mov CARG1, CTSTATE
  |  mov CARG2, RA
  |  bl extern lj_ccallback_leave    // (CTState *cts, TValue *o)
  |  ldrd CARG12, CTSTATE->cb.gpr[0]
  |.if HFABI
  |  vldr d0, CTSTATE->cb.fpr[0]
  |.endif
  |  b ->vm_leave_unw
  |.endif
  |
  |->vm_ffi_call:            // Call C function via FFI.
  |  // Caveat: needs special frame unwinding, see below.
  |.if FFI
  |  .type CCSTATE, CCallState, r4
  |  push {CCSTATE, r5, r11, lr}
  |  mov CCSTATE, CARG1
  |  ldr CARG1, CCSTATE:CARG1->spadj
  |   ldrb CARG2, CCSTATE->nsp
  |    add CARG3, CCSTATE, #offsetof(CCallState, stack)
  |.if HFABI
  |  add RB, CCSTATE, #offsetof(CCallState, fpr[0])
  |.endif
  |  mov r11, sp
  |  sub sp, sp, CARG1            // Readjust stack.
  |   subs CARG2, CARG2, #1
  |.if HFABI
  |  vldm RB, {d0-d7}
  |.endif
  |    ldr RB, CCSTATE->func
  |   bmi >2
  |1:  // Copy stack slots.
  |  ldr CARG4, [CARG3, CARG2, lsl #2]
  |  str CARG4, [sp, CARG2, lsl #2]
  |  subs CARG2, CARG2, #1
  |  bpl <1
  |2:
  |  ldrd CARG12, CCSTATE->gpr[0]
  |  ldrd CARG34, CCSTATE->gpr[2]
  |  blx RB
  |  mov sp, r11
  |.if HFABI
  |  add r12, CCSTATE, #offsetof(CCallState, fpr[4])
  |.endif
  |  strd CRET1, CCSTATE->gpr[0]
  |.if HFABI
  |  vstmdb r12!, {d0-d3}
  |.endif
  |  pop {CCSTATE, r5, r11, pc}
  |.endif
  |// Note: vm_ffi_call must be the last function in this object file!
  |
  |//-----------------------------------------------------------------------
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
  int vk = 0;
  |=>defop:

  switch (op) {

  /* -- Comparison ops ---------------------------------------------------- */

  /* Remember: all ops branch for a true comparison, fall through otherwise. */

  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
    |  // RA = src1*8, RC = src2, JMP with RC = target
    |  add RA, BASE, RA
    |  ldp CARG1w, CARG2w, [RA]
    |    ldrh RB, [PC, #2]
    |   add RC, BASE, RC, lsl #3
    |   ldp CARG3w, CARG4w, [RC]
    |    add PC, PC, #4
    |    add RB, PC, RB, lsl #2
    |    sub RB, RB, #0x20, lsl #12      // RB = RB - 0x20000
    |  checktp CARG2w, LJ_TISNUM
    |  b.ne >3
    |  checktp CARG4w, LJ_TISNUM
    |  b.ne >4
    |  cmp CARG1, CARG3
    if (op == BC_ISLT) {
      |  csel PC, RB, PC, lt
    } else if (op == BC_ISGE) {
      |  csel PC, RB, PC, ge
    } else if (op == BC_ISLE) {
      |  csel PC, RB, PC, le
    } else {
      |  csel PC, RB, PC, gt
    }
    |1:
    |  ins_next
    |
    |3: // CARG12 is not an integer.
    |.if FPU
    |   ldr d0, [RA]
    |  b.hi ->vmeta_comp
    |  // d0 is a number.
    |  checktp CARG4w, LJ_TISNUM
    |   ldr d1, [RC]
    |  b.lo >5
    |  b.hi ->vmeta_comp
    |  // d0 is a number, CARG3 is an integer.
    |  fmov s4, CARG3w
    |  fcvt d1, s4
    |  b >5
    |4:  // CARG1 is an integer, CARG34 is not an integer.
    |   ldr d1, [RC]
    |  b.hi ->vmeta_comp
    |  // CARG1 is an integer, d1 is a number.
    |  fmov s4, CARG1w
    |  fcvt d0, s4
    |5:  // d0 and d1 are numbers.
    |  fcmp d0, d1
    |  // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
    if (op == BC_ISLT) {
      |  csel PC, RB, PC, lo
    } else if (op == BC_ISGE) {
      |  csel PC, RB, PC, hs
    } else if (op == BC_ISLE) {
      |  csel PC, RB, PC, ls
    } else {
      |  csel PC, RB, PC, hi
    }
    |  b <1
    |.else
    |  b.hi ->vmeta_comp
    |  // CARG12 is a number.
    |  checktp CARG4w, LJ_TISNUM
    |  b.hi ->vmeta_comp
    |  csel RA, RB, RA, lo   // Save RB.
    |  b.lo >5
    |  // CARG12 is a number, CARG3 is an integer.
    |  mov CARG1, CARG3
    |  mov RC, RA
    |  mov RA, RB            // Save RB.
    |  bl extern __aeabi_i2d
    |  mov CARG3, CARG1
    |  mov CARG4, CARG2
    |  ldp CARG1w, CARG2w, [RC]        // Restore first operand.
    |  b >5
    |4:  // CARG1 is an integer, CARG34 is not an integer.
    |  b.hi ->vmeta_comp
    |  // CARG1 is an integer, CARG34 is a number.
    |  mov RA, RB            // Save RB.
    |  bl extern __aeabi_i2d
    |  ldp CARG3w, CARG4w, [RC]        // Restore second operand.
    |5:  // CARG12 and CARG34 are numbers.
    |  bl extern __aeabi_cdcmple
    |  // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
    if (op == BC_ISLT) {
      |  csel PC, RA, PC, lo
    } else if (op == BC_ISGE) {
      |  csel PC, RA, PC, hs
    } else if (op == BC_ISLE) {
      |  csel PC, RA, PC, ls
    } else {
      |  csel PC, RA, PC, hi
    }
    |  b <1
    |.endif
    break;

  case BC_ISEQV: case BC_ISNEV:
    vk = op == BC_ISEQV;
    |  // RA = src1*8, RC = src2, JMP with RC = target
    |  add RA, BASE, RA
    |  ldp CARG1w, CARG2w, [RA]
    |    ldrh RB, [PC, #2]
    |   add RC, BASE, RC, lsl #3
    |   ldp CARG3w, CARG4w, [RC]
    |    add PC, PC, #4
    |    add RB, PC, RB, lsl #2
    |    sub RB, RB, #0x20, lsl #12
    |  checktp CARG2w, LJ_TISNUM
    |  ccmn CARG4w, #-LJ_TISNUM, #2, ls
    if (vk) {
      |  b.ls ->BC_ISEQN_Z
    } else {
      |  b.ls ->BC_ISNEN_Z
    }
    |  // Either or both types are not numbers.
    |.if FFI
    |  checktp CARG2w, LJ_TCDATA
    |  checktpne CARG4w, LJ_TCDATA
    |  b.eq ->vmeta_equal_cd
    |.endif
    |  cmp CARG2, CARG4            // Compare types.
    |  b.ne >2                // Not the same type?
    |  checktp CARG2w, LJ_TISPRI
    |  b.hs >1                // Same type and primitive type?
    |
    |  // Same types and not a primitive type. Compare GCobj or pvalue.
    |  cmp CARG1, CARG3
    if (vk) {
      |  b.ne >3                // Different GCobjs or pvalues?
      |1:  // Branch if same.
      |  mov PC, RB
      |2:  // Different.
      |  ins_next
      |3:
      |  checktp CARG2w, LJ_TISTABUD
      |  b.hi <2                // Different objects and not table/ud?
    } else {
      |  b.eq >1                // Same GCobjs or pvalues?
      |  checktp CARG2w, LJ_TISTABUD
      |  b.hi >2                // Different objects and not table/ud?
    }
    |  // Different tables or userdatas. Need to check __eq metamethod.
    |  // Field metatable must be at same offset for GCtab and GCudata!
    |  ldr TAB:RAw, TAB:CARG1->metatable
    |  cmp TAB:RA, #0
    if (vk) {
      |  b.eq <2            // No metatable?
    } else {
      |  b.eq >2            // No metatable?
    }
    |  ldrb RAw, TAB:RA->nomm
    |   mov CARG4w, #1-vk        // ne = 0 or 1.
    |   mov CARG2, CARG1
    |  tst RAw, #1<<MM_eq
    |  b.eq ->vmeta_equal        // 'no __eq' flag not set?
    if (vk) {
      |  b <2
    } else {
      |2:  // Branch if different.
      |  mov PC, RB
      |1:  // Same.
      |  ins_next
    }
    break;

  case BC_ISEQS: case BC_ISNES:
    vk = op == BC_ISEQS;
    |  // RA = src*8, RC = str_const (~), JMP with RC = target
    |   mvn RC, RC
    |  ldp CARG1w, CARG2w, [BASE, RA]
    |    ldrh RBw, [PC, #2]
    |   ldr STR:CARG3w, [KBASE, RC, lsl #2]
    |    add PC, PC, #4
    |    add RB, PC, RB, lsl #2
    |    sub RB, RB, #0x20, lsl #12
    |  checktp CARG2w, LJ_TSTR
    |.if FFI
    |  b.ne >7
    |  cmp CARG1, CARG3
    |.else
    |  ccmp CARG1, CARG3, #0, eq
    |.endif
    if (vk) {
      |  csel PC, RB, PC, eq
      |1:
    } else {
      |1:
      |  csel PC, RB, PC, ne
    }
    |  ins_next
    |
    |.if FFI
    |7:
    |  checktp CARG2w, LJ_TCDATA
    |  b.ne <1
    |  b ->vmeta_equal_cd
    |.endif
    break;

  case BC_ISEQN: case BC_ISNEN:
    vk = op == BC_ISEQN;
    |  // RA = src*8, RC = num_const (~), JMP with RC = target
    |  add RA, BASE, RA
    |  ldp CARG1w, CARG2w, [RA]
    |    ldrh RBw, [PC, #2]
    |   add RC, KBASE, RC, lsl #3
    |   ldp CARG3w, CARG4w, [RC]
    |    add PC, PC, #4
    |    add RB, PC, RB, lsl #2
    |    sub RB, RB, #0x20, lsl #12
    if (vk) {
      |->BC_ISEQN_Z:
    } else {
      |->BC_ISNEN_Z:
    }
    |  checktp CARG2w, LJ_TISNUM
    |  b.ne >3
    |  checktp CARG4w, LJ_TISNUM
    |  b.ne >4
    |  cmp CARG1, CARG3
    if (vk) {
      |  csel PC, RB, PC, eq
      |1:
    } else {
      |1:
      |  csel PC, RB, PC, ne
    }
    |2:
    |  ins_next
    |
    |3:  // CARG12 is not an integer.
    |.if FFI
    |  b.hi >7
    |.else
    if (!vk) {
      |  csel PC, RB, PC, hi
    }
    |  b.hi <2
    |.endif
    |.if FPU
    |  checktp CARG4w, LJ_TISNUM
    |  fmov s4, CARG3w
    |  fcvt d2, s4
    |   ldr d0, [RA]
    |  ldr d1, [RC]
    |  fcsel d1, d1, d2, lo
    |  b >5
    |4:  // CARG1 is an integer, d1 is a number.
    |  fmov s4, CARG1w
    |   ldr d1, [RC]
    |  fcvt d0, s4
    |5:  // d0 and d1 are numbers.
    |  fcmp d0, d1
    if (vk) {
      |  csel PC, RB, PC, eq
    } else {
      |  csel PC, RB, PC, ne
    }
    |  b <2
    |.else
    |  // CARG12 is a number.
    |  checktp CARG4w, LJ_TISNUM
    |  csel RA, RB, RA, lo     // Save RB.
    |  b.lo >5
    |  // CARG12 is a number, CARG3 is an integer.
    |  mov CARG1, CARG3
    |  mov RC, RA
    |4:  // CARG1 is an integer, CARG34 is a number.
    |  mov RA, RB            // Save RB.
    |  bl extern __aeabi_i2d
    |  ldp CARG3w, CARG4w, [RC]        // Restore other operand.
    |5:  // CARG12 and CARG34 are numbers.
    |  bl extern __aeabi_cdcmpeq
    if (vk) {
      |  csel PC, RA, PC, eq
    } else {
      |  csel PC, RA, PC, ne
    }
    |  b <2
    |.endif
    |
    |.if FFI
    |7:
    |  checktp CARG2w, LJ_TCDATA
    |  b.ne <1
    |  b ->vmeta_equal_cd
    |.endif
    break;

  case BC_ISEQP: case BC_ISNEP:
    vk = op == BC_ISEQP;
    |  // RA = src*8, RC = primitive_type (~), JMP with RC = target
    |  add RA, BASE, RA
    |  ldp CARG1w, CARG2w, [RA]
    |   ldrh RBw, [PC, #2]
    |   add PC, PC, #4
    |  mvn RC, RC
    |   add RB, PC, RB, lsl #2
    |   sub RB, RB, #0x20, lsl #12
    |.if FFI
    |  checktp CARG2w, LJ_TCDATA
    |  b.eq ->vmeta_equal_cd
    |.endif
    |  cmp CARG2, RC
    if (vk) {
      |  csel PC, RB, PC, eq
    } else {
      |  csel PC, RB, PC, ne
    }
    |  ins_next
    break;

  /* -- Unary test and copy ops ------------------------------------------- */

  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
    |  // RA = dst*8 or unused, RC = src, JMP with RC = target
    |  add RA, BASE, RA
    |  add RC, BASE, RC, lsl #3
    |   ldrh RBw, [PC, #2]
    |  ldp CARG1w, CARG2w, [RC]
    |   add PC, PC, #4
    |   add RB, PC, RB, lsl #2
    |   sub RB, RB, #0x20, lsl #12
    |  checktp CARG2w, LJ_TTRUE
    if (op == BC_ISTC || op == BC_IST) {
      |  csel PC, RB, PC, ls
      if (op == BC_ISTC) {
    |  b.hi >1
    |  stp CARG1w, CARG2w, [RA]
      }
    } else {
      |  csel PC, RB, PC, hi
      if (op == BC_ISFC) {
    |  b.ls >1
    |  stp CARG1w, CARG2w, [RA]
      }
    }
    |1:
    |  ins_next
    break;

  case BC_ISTYPE:
    |  // RA = src*8, RC = -type
    |  add RA, BASE, RA
    |  ldp CARG1w, CARG2w, [RA]
    |   ins_next1
    |  cmn CARG2w, RCw
    |   ins_next2
    |  b.ne ->vmeta_istype
    |   ins_next3
    break;
  case BC_ISNUM:
    |  // RA = src*8, RC = -(TISNUM-1)
    |  add RA, BASE, RA
    |  ldp CARG1w, CARG2w, [RA]
    |   ins_next1
    |  checktp CARG2w, LJ_TISNUM
    |   ins_next2
    |  b.hs ->vmeta_istype
    |   ins_next3
    break;

  /* -- Unary ops --------------------------------------------------------- */

  case BC_MOV:
    |  // RA = dst*8, RC = src
    |   ins_next1
    |  ldr CARG1, [BASE, RC, lsl #3]     // 8 bytes
    |   ins_next2
    |  str CARG1, [BASE, RA]
    |   ins_next3
    break;
  case BC_NOT:
    |  // RA = dst*8, RC = src
    |  add RC, BASE, RC, lsl #3
    |   ins_next1
    |  ldr CARG1w, [RC, #4]
    |   add RA, BASE, RA
    |   ins_next2
    |  checktp CARG1w, LJ_TTRUE
    |  mov CARG2w, #LJ_TTRUE
    |  cinc CARG2w, CARG2w, ls     //LJ_TFALSE = LJ_TTRUE + 1
    |  str CARG2w, [RA, #4]
    |   ins_next3
    break;
  case BC_UNM:
    |  // RA = dst*8, RC = src
    |  add RC, BASE, RC, lsl #3
    |  ldp CARG1w, CARG2w, [RC]
    |   ins_next1
    |   ins_next2
    |  checktp CARG2w, LJ_TISNUM
    |  b.hi ->vmeta_unm
    |  eor CARG3w, CARG2w, #0x80000000
    |  csel CARG2w, CARG3w, CARG2w, ne
    |  b.ne >5
    |  negs CARG1w, CARG1w
    |  b.vc >5
    |  ldr CARG1, >9
    |  lsr CARG2, CARG1, #32
    |5:
    |  add RA, BASE, RA
    |  stp CARG1w, CARG2w, [RA]
    |   ins_next3
    |
    |.align 8
    |9:
    |  .long 0x00000000, 0x41e00000    // 2^31.
    break;
  case BC_LEN:
    |  // RA = dst*8, RC = src
    |  add RC, BASE, RC, lsl #3
    |  ldp CARG1w, CARG2w, [RC]
    |  checkstr CARG2w, >2
    |  ldr CARG1w, STR:CARG1->len
    |1:
    |  mov CARG2w, #LJ_TISNUM
    |   ins_next1
    |   ins_next2
    |  add RA, BASE, RA
    |  stp CARG1w, CARG2w, [RA]
    |   ins_next3
    |2:
    |  checktab CARG2w, ->vmeta_len
#if LJ_52
    |  ldr TAB:CARG3w, TAB:CARG1->metatable
    |  cmp TAB:CARG3w, #0
    |  b.ne >9
    |3:
#endif
    |->BC_LEN_Z:
    |  bl extern lj_tab_len        // (GCtab *t)
    |  // Returns uint32_t (but less than 2^31).
    |  b <1
#if LJ_52
    |9:
    |  ldrb CARG4w, TAB:CARG3->nomm
    |  tst CARG4w, #1<<MM_len
    |  b.ne <3                // 'no __len' flag set: done.
    |  b ->vmeta_len
#endif
    break;

  /* -- Binary ops -------------------------------------------------------- */

    |.macro ins_arithcheck, cond, bnc, nzcv, target
    ||if (vk == 1) {
    |   cmn CARG4w, #-LJ_TISNUM
    |    ccmn CARG2w, #-LJ_TISNUM, nzcv, cond
    ||} else {
    |   cmn CARG2w, #-LJ_TISNUM
    |    ccmn CARG4w, #-LJ_TISNUM, nzcv, cond
    ||}
    |  bnc target
    |.endmacro
    |.macro ins_arithcheck_int, target
    |  ins_arithcheck eq, b.ne, #0, target
    |.endmacro
    |.macro ins_arithcheck_num, target
    |  ins_arithcheck lo, b.hs, #2, target
    |.endmacro
    |
    |.macro ins_arithpre
    |  decode_RB8 RBw, INSw
    |   decode_RC8 RCw, INSw
    |  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
    |  add RA, BASE, RA
    |  add RB, BASE, RB
    ||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    ||switch (vk) {
    ||case 0:
    |   add RC, KBASE, RC
    |   ldp CARG1w, CARG2w, [RB]
    |    ldp CARG3w, CARG4w, [RC]
    ||  break;
    ||case 1:
    |   add RC, KBASE, RC
    |   ldp CARG3w, CARG4w, [RB]
    |    ldp CARG1w, CARG2w, [RC]
    ||  break;
    ||default:
    |   add RC, BASE, RC
    |   ldp CARG1w, CARG2w, [RB]
    |    ldp CARG3w, CARG4w, [RC]
    ||  break;
    ||}
    |.endmacro
    |
    |.macro ins_arithpre_fpu, reg1, reg2
    |.if FPU
    ||if (vk == 1) {
    |  ldr reg2, [RB]
    |  ldr reg1, [RC]
    ||} else {
    |  ldr reg1, [RB]
    |  ldr reg2, [RC]
    ||}
    |.endif
    |.endmacro
    |
    |.macro ins_arithpost_fpu, reg
    |   ins_next1
    |   ins_next2
    |  str reg, [RA]
    |   ins_next3
    |.endmacro
    |
    |.macro ins_arithfallback, ins
    ||switch (vk) {
    ||case 0:
    |   ins ->vmeta_arith_vn
    ||  break;
    ||case 1:
    |   ins ->vmeta_arith_nv
    ||  break;
    ||default:
    |   ins ->vmeta_arith_vv
    ||  break;
    ||}
    |.endmacro
    |
    |.macro ins_arithdn, intins, fpins, fpcall
    |  ins_arithpre
    |.if "intins" ~= "vm_modi" and not FPU
    |   ins_next1
    |.endif
    |  ins_arithcheck_int >5
    |.if "intins" == "smull"
    |  smull CARG1, CARG3w, CARG1w
    |  bfxil RC, CARG1, 32, 32
    |  cmp RCw, CARG1w, asr #31
    |  ins_arithfallback b.ne
    |.elif "intins" == "vm_modi"
    |  mov CARG2w, CARG3w
    |  cmp CARG3w, #0
    |  ins_arithfallback b.eq
    |  bl ->vm_modi
    |  mov CARG2w, #LJ_TISNUM
    |.else
    |  intins CARG1w, CARG1w, CARG3w
    |  ins_arithfallback b.vs
    |.endif
    |4:
    |.if "intins" == "vm_modi" or FPU
    |   ins_next1
    |.endif
    |   ins_next2
    |  stp CARG1w, CARG2w, [RA]
    |   ins_next3
    |5:  // FP variant.
    |  ins_arithpre_fpu d6, d7
    |  ins_arithfallback ins_arithcheck_num
    |.if FPU
    |.if "intins" == "vm_modi"
    |  bl fpcall
    |.else
    |  fpins d6, d6, d7
    |.endif
    |  ins_arithpost_fpu d6
    |.else
    |  bl fpcall
    |.if "intins" ~= "vm_modi"
    |  ins_next1
    |.endif
    |  b <4
    |.endif
    |.endmacro
    |
    |.macro ins_arithfp, fpins, fpcall
    |  ins_arithpre
    |.if "fpins" ~= "extern" or HFABI
    |  ins_arithpre_fpu d0, d1
    |.endif
    |  ins_arithfallback ins_arithcheck_num
    |.if "fpins" == "extern"
    |  bl fpcall
    |.elif FPU
    |  fpins d0, d0, d1
    |.else
    |  bl fpcall
    |.endif
    |.if ("fpins" ~= "extern" or HFABI) and FPU
    |  ins_arithpost_fpu d0
    |.else
    |   ins_next1
    |   ins_next2
    |  stp CARG1w, CARG2w, [RA]
    |   ins_next3
    |.endif
    |.endmacro

  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
    |  ins_arithdn adds, fadd, extern __aeabi_dadd
    break;
  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
    |  ins_arithdn subs, fsub, extern __aeabi_dsub
    break;
  case BC_MULVN: case BC_MULNV: case BC_MULVV:
    |  ins_arithdn smull, fmul, extern __aeabi_dmul
    break;
  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
    |  ins_arithfp fdiv, extern __aeabi_ddiv
    break;
  case BC_MODVN: case BC_MODNV: case BC_MODVV:
    |  ins_arithdn vm_modi, vm_mod, ->vm_mod
    break;
  case BC_POW:
    |  // NYI: (partial) integer arithmetic.
    |  ins_arithfp extern, extern pow
    break;

  case BC_CAT:
    |  decode_RB8 RCw, INSw
    |   decode_RC8 RBw, INSw
    |  // RA = dst*8, RC = src_start*8, RB = src_end*8  (note: RB/RC swapped!)
    |  sub CARG3, RB, RC
    |   str BASE, L->base
    |  add CARG2, BASE, RB
    |->BC_CAT_Z:
    |  // RA = dst*8, RC = src_start*8, CARG2 = top-1
    |  mov CARG1, L
    |   str PCw, SAVE_PC
    |  lsr CARG3, CARG3, #3
    |  bl extern lj_meta_cat        // (lua_State *L, TValue *top, int left)
    |  // Returns NULL (finished) or TValue * (metamethod).
    |  ldr BASE, L->base
    |  cmp CRET1, #0
    |  b.ne ->vmeta_binop
    |  ldr CARG3, [BASE, RC]
    |   ins_next1
    |   ins_next2
    |  str CARG3, [BASE, RA]        // Copy result to RA.
    |   ins_next3
    break;

  /* -- Constant ops ------------------------------------------------------ */

  case BC_KSTR:
    |  // RA = dst*8, RC = str_const (~)
    |  mvn RC, RC
    |   ins_next1
    |  ldr CARG1w, [KBASE, RC, lsl #2]
    |  mov CARG2w, #LJ_TSTR
    |   ins_next2
    |  add RA, BASE, RA
    |  stp CARG1w, CARG2w, [RA]
    |   ins_next3
    break;
  case BC_KCDATA:
    |.if FFI
    |  // RA = dst*8, RC = cdata_const (~)
    |  mvn RC, RC
    |   ins_next1
    |  ldr CARG1w, [KBASE, RC, lsl #2]
    |  mov CARG2w, #LJ_TCDATA
    |   ins_next2
    |  add RA, BASE, RA
    |  stp CARG1w, CARG2w, [RA]
    |   ins_next3
    |.endif
    break;
  case BC_KSHORT:
    |  // RA = dst*8, (RC = int16_literal)
    |  asr CARG1w, INSw, #16            // Refetch sign-extended reg.
    |  mov CARG2w, #LJ_TISNUM
    |   ins_next1
    |   ins_next2
    |  add RA, BASE, RA
    |  stp CARG1w, CARG2w, [RA]
    |   ins_next3
    break;
  case BC_KNUM:
    |  // RA = dst*8, RC = num_const
    |  lsl RCw, RCw, #3
    |   ins_next1
    |  ldr CARG1, [KBASE, RC]
    |   ins_next2
    |  str CARG1, [BASE, RA]
    |   ins_next3
    break;
  case BC_KPRI:
    |  // RA = dst*8, RC = primitive_type (~)
    |  add RA, BASE, RA
    |  mvn RC, RC
    |   ins_next1
    |   ins_next2
    |  str RCw, [RA, #4]
    |   ins_next3
    break;
  case BC_KNIL:
    |  // RA = base*8, RC = end
    |  add RA, BASE, RA
    |   add RC, BASE, RC, lsl #3
    |  mov CARG1w, #LJ_TNIL
    |  str CARG1w, [RA, #4]
    |   add RA, RA, #8
    |1:
    |  str CARG1w, [RA, #4]
    |  cmp RA, RC
    |   add RA, RA, #8
    |  b.lt <1
    |  ins_next_
    break;

  /* -- Upvalue and function ops ------------------------------------------ */

  case BC_UGET:
    |  // RA = dst*8, RC = uvnum
    |  ldr LFUNC:CARG2w, [BASE, FRAME_FUNC]
    |   lsl RCw, RCw, #2
    |   add RCw, RCw, #offsetof(GCfuncL, uvptr)
    |  ldr UPVAL:CARG2w, [LFUNC:CARG2, RC]
    |  ldr CARG2w, UPVAL:CARG2->v
    |  ldr CARG3, [CARG2]
    |   ins_next1
    |   ins_next2
    |  str CARG3, [BASE, RA]
    |   ins_next3
    break;
  case BC_USETV:
    |  // RA = uvnum*8, RC = src
    |  ldr LFUNC:CARG2w, [BASE, FRAME_FUNC]
    |   lsr RA, RA, #1
    |   add RA, RA, #offsetof(GCfuncL, uvptr)
    |    add RC, BASE, RC, lsl #3
    |  ldr UPVAL:CARG2w, [LFUNC:CARG2, RA]
    |    ldp CARG3w, CARG4w, [RC]
    |  ldrb RBw, UPVAL:CARG2->marked
    |  ldrb RCw, UPVAL:CARG2->closed
    |    ldr CARG2w, UPVAL:CARG2->v
    |  tst RBw, #LJ_GC_BLACK        // isblack(uv)
    |   add RBw, CARG4w, #-LJ_TISGCV
    |  ccmp RCw, #0, #4, ne
    |   stp CARG3w, CARG4w, [CARG2]
    |  b.ne >2                // Upvalue is closed and black?
    |1:
    |   ins_next
    |
    |2:  // Check if new value is collectable.
    |  cmn RBw, #-(LJ_TNUMX - LJ_TISGCV)
    |  b.ls <1                // tvisgcv(v)
    |   ldrb RCw, GCOBJ:CARG3->gch.marked
    |    sub CARG1, DISPATCH, #-GG_DISP2G
    |   tst RCw, #LJ_GC_WHITES
    |  // Crossed a write barrier. Move the barrier forward.
    |  b.eq <1
    |  bl extern lj_gc_barrieruv    // (global_State *g, TValue *tv)
    |  b <1
    break;
  case BC_USETS:
    |  // RA = uvnum*8, RC = str_const (~)
    |  ldr LFUNC:CARG2w, [BASE, FRAME_FUNC]
    |   lsr RA, RA, #1
    |   add RA, RA, #offsetof(GCfuncL, uvptr)
    |    mvn RC, RC
    |  ldr UPVAL:CARG2w, [LFUNC:CARG2, RA]
    |    ldr STR:CARG3w, [KBASE, RC, lsl #2]
    |    mov CARG4w, #LJ_TSTR
    |  ldrb RBw, UPVAL:CARG2->marked
    |   ldr CARG2w, UPVAL:CARG2->v
    |     ldrb RCw, UPVAL:CARG2->closed
    |  tst RBw, #LJ_GC_BLACK        // isblack(uv)
    |    ldrb RBw, STR:CARG3->marked
    |   stp CARG3w, CARG4w, [CARG2]
    |  b.ne >2
    |1:
    |   ins_next
    |
    |2:  // Check if string is white and ensure upvalue is closed.
    |  tst RBw, #LJ_GC_WHITES        // iswhite(str)
    |  ccmp RCw, #0, #4, ne
    |   sub CARG1, DISPATCH, #-GG_DISP2G
    |  // Crossed a write barrier. Move the barrier forward.
    |  b.eq <1
    |  bl extern lj_gc_barrieruv    // (global_State *g, TValue *tv)
    |  b <1
    break;
  case BC_USETN:
    |  // RA = uvnum*8, RC = num_const
    |  ldr LFUNC:CARG2w, [BASE, FRAME_FUNC]
    |   lsr RA, RA, #1
    |   add RA, RA, #offsetof(GCfuncL, uvptr)
    |    lsl RC, RC, #3
    |  ldr UPVAL:CARG2w, [LFUNC:CARG2, RA]
    |    ldr CARG3, [KBASE, RC]
    |  ldr CARG2w, UPVAL:CARG2->v
    |   ins_next1
    |   ins_next2
    |  str CARG3, [CARG2]
    |   ins_next3
    break;
  case BC_USETP:
    |  // RA = uvnum*8, RC = primitive_type (~)
    |  ldr LFUNC:CARG2w, [BASE, FRAME_FUNC]
    |   lsr RA, RA, #1
    |   add RA, RA, #offsetof(GCfuncL, uvptr)
    |  ldr UPVAL:CARG2w, [LFUNC:CARG2, RA]
    |   mvn RCw, RCw
    |  ldr CARG2w, UPVAL:CARG2->v
    |   ins_next1
    |   ins_next2
    |  str RCw, [CARG2, #4]
    |   ins_next3
    break;

  case BC_UCLO:
    |  // RA = level*8, RC = target
    |  ldr CARG3w, L->openupval
    |   add RC, PC, RC, lsl #2
    |   str BASE, L->base
    |  cmp CARG3, #0
    |   sub PC, RC, #0x20, lsl #12
    |  b.eq >1
    |   mov CARG1, L
    |   add CARG2, BASE, RA
    |  bl extern lj_func_closeuv    // (lua_State *L, TValue *level)
    |  ldr BASE, L->base
    |1:
    |  ins_next
    break;

  case BC_FNEW:
    |  // RA = dst*8, RC = proto_const (~) (holding function prototype)
    |  mvn RC, RC
    |   str BASE, L->base
    |  ldr CARG2w, [KBASE, RC, lsl #2]
    |   str PCw, SAVE_PC
    |  ldr CARG3w, [BASE, FRAME_FUNC]
    |   mov CARG1, L
    |  // (lua_State *L, GCproto *pt, GCfuncL *parent)
    |  bl extern lj_func_newL_gc
    |  // Returns GCfuncL *.
    |  ldr BASE, L->base
    |  mov CARG2w, #LJ_TFUNC
    |   ins_next1
    |   ins_next2
    |  stp CARG1w, CARG2w, [BASE, RA]
    |   ins_next3
    break;

  /* -- Table ops --------------------------------------------------------- */

  case BC_TNEW:
  case BC_TDUP:
    |  // RA = dst*8, RC = (hbits|asize) | tab_const (~)
    if (op == BC_TDUP) {
      |  mvn RC, RC
    }
    |  ldr CARG3w, [DISPATCH, #DISPATCH_GL(gc.total)]
    |   ldr CARG4w, [DISPATCH, #DISPATCH_GL(gc.threshold)]
    |    str BASE, L->base
    |    str PCw, SAVE_PC
    |  cmp CARG3w, CARG4w
    |   mov CARG1, L
    |  b.hs >5
    |1:
    if (op == BC_TNEW) {
      |  lsl CARG2w, RCw, #21
      |   lsr CARG3w, RCw, #11
      |  asr RCw, CARG2w, #21
      |  lsr CARG2w, CARG2w, #21
      |  cmn RCw, #1
      |  add CARG4w, CARG2w, #2
      |  csel CARG2w, CARG4w, CARG2w, eq
      |  bl extern lj_tab_new  // (lua_State *L, int32_t asize, uint32_t hbits)
      |  // Returns GCtab *.
    } else {
      |  ldr CARG2w, [KBASE, RC, lsl #2]
      |  bl extern lj_tab_dup  // (lua_State *L, Table *kt)
      |  // Returns GCtab *.
    }
    |  ldr BASE, L->base
    |  mov CARG2w, #LJ_TTAB
    |   ins_next1
    |  add RA, BASE, RA
    |   ins_next2
    |  stp CARG1w, CARG2w, [RA]
    |   ins_next3
    |5:
    |  bl extern lj_gc_step_fixtop  // (lua_State *L)
    |  mov CARG1, L
    |  b <1
    break;

  case BC_GGET:
    |  // RA = dst*8, RC = str_const (~)
  case BC_GSET:
    |  // RA = dst*8, RC = str_const (~)
    |  add RA, BASE, RA
    |  ldr LFUNC:CARG2w, [BASE, FRAME_FUNC]
    |   mvn RC, RC
    |  ldr TAB:CARG1w, LFUNC:CARG2->env
    |   ldr STR:RCw, [KBASE, RC, lsl #2]
    if (op == BC_GGET) {
      |  b ->BC_TGETS_Z
    } else {
      |  b ->BC_TSETS_Z
    }
    break;

  case BC_TGETV:
    |  decode_RB8 RBw, INSw
    |   decode_RC8 RCw, INSw
    |  // RA = dst*8, RB = table*8, RC = key*8
    |  // CARG1 = BASE+RA, CARG2 = BASE+RB, CARG3 = BASE+RC
    |  add RA, BASE, RA   // dst
    |  add RB, BASE, RB   // table
    |  add RC, BASE, RC   // key
    |  ldp TAB:CARG1w, CARG2w, [RB]
    |   ldp CARG3w, CARG4w, [RC]
    |  checktab CARG2w, ->vmeta_tgetv  // STALL: load CARG12.
    |   checktp CARG4w, LJ_TISNUM    // Integer key?
    |   b.ne >9
    |  ldr CARG4w, TAB:CARG1->array
    |    ldr CARG2w, TAB:CARG1->asize
    |
    |  add CARG4w, CARG4w, CARG3w, lsl #3
    |    cmp CARG3w, CARG2w        // In array part?
    |    b.hs ->vmeta_tgetv
    |  ldp CARG3w, CARG4w, [CARG4]
    |   ins_next1  // Overwrites RB!
    |  checktp CARG4w, LJ_TNIL
    |  b.eq >5
    |1:
    |   ins_next2
    |  stp CARG3w, CARG4w, [RA]
    |   ins_next3
    |
    |5:  // Check for __index if table value is nil.
    |  ldr TAB:CARG2w, TAB:CARG1->metatable
    |  cbz TAB:CARG2w, <1    // No metatable: done.
    |  ldrb CARG2w, TAB:CARG2->nomm
    |  tst CARG2w, #1<<MM_index
    |  b.ne <1                // 'no __index' flag set: done.
    |  b ->vmeta_tgetv
    |
    |9:
    |  checktp CARG4w, LJ_TSTR        // String key?
    |   csel STR:RCw, CARG3w, RCw, eq
    |  b.eq ->BC_TGETS_Z
    |  b ->vmeta_tgetv
    break;
  case BC_TGETS:
    |  decode_RB8 RBw, INSw
    |   and RCw, RCw, #255
    |  // RA = dst*8, RB = table*8, RC = str_const (~)
    |  add RA, BASE, RA
    |  add RB, BASE, RB
    |  ldp CARG1w, CARG2w, [RB]
    |   mvn RC, RC
    |   ldr STR:RCw, [KBASE, RC, lsl #2]  // STALL: early RC.
    |  checktab CARG2w, ->vmeta_tgets1
    |->BC_TGETS_Z:
    |  // (TAB:RB =) TAB:CARG1 = GCtab *, STR:RC = GCstr *, RA = dst
    |  ldr CARG3w, TAB:CARG1->hmask
    |   ldr CARG4w, STR:RC->hash
    |    ldr NODE:INSw, TAB:CARG1->node
    |     mov TAB:RB, TAB:CARG1
    |  and CARG3w, CARG3w, CARG4w            // idx = str->hash & tab->hmask
    |  add CARG3w, CARG3w, CARG3w, lsl #1
    |    add NODE:INSw, NODE:INSw, CARG3w, lsl #3    // node = tab->node + idx*3*8
    |1:
    |  ldp CARG1w, CARG2w, NODE:INS->key  // STALL: early NODE:INS.
    |   ldp CARG3w, CARG4w, NODE:INS->val
    |    ldr NODE:INSw, NODE:INS->next
    |  checktp CARG2w, LJ_TSTR
    |  ccmp CARG1w, STR:RCw, #0, eq
    |  b.ne >4
    |   checktp CARG4w, LJ_TNIL
    |   b.eq >5
    |3:
    |   ins_next1
    |   ins_next2
    |  stp CARG3w, CARG4w, [RA]
    |   ins_next3
    |
    |4:  // Follow hash chain.
    |  cbnz NODE:INSw, <1
    |  // End of hash chain: key not found, nil result.
    |
    |5:  // Check for __index if table value is nil.
    |  ldr TAB:CARG1w, TAB:RB->metatable
    |   mov CARG3w, #0  // Optional clear of undef. value (during load stall).
    |   mov CARG4w, #LJ_TNIL
    |  cbz TAB:CARG1w, <3     // No metatable: done.
    |  ldrb CARG2w, TAB:CARG1->nomm
    |  tst CARG2w, #1<<MM_index
    |  b.ne <3                // 'no __index' flag set: done.
    |  b ->vmeta_tgets
    break;
  case BC_TGETB:
    |  decode_RB8 RBw, INSw
    |   and RC, RC, #255
    |  // RA = dst*8, RB = table*8, RC = index
    |  add RA, BASE, RA
    |  add RB, BASE, RB
    |  ldp CARG1w, CARG2w, [RB]
    |  checktab CARG2w, ->vmeta_tgetb  // STALL: load CARG12.
    |   ldr CARG3w, TAB:CARG1->asize
    |  ldr CARG4w, TAB:CARG1->array
    |  add CARG4, CARG4, RC, lsl #3
    |   cmp RC, CARG3
    |   b.hs ->vmeta_tgetb
    |  ldp CARG3w, CARG4w, [CARG4]
    |   ins_next1  // Overwrites RB!
    |  checktp CARG4w, LJ_TNIL
    |  b.eq >5
    |1:
    |   ins_next2
    |  stp CARG3w, CARG4w, [RA]
    |   ins_next3
    |
    |5:  // Check for __index if table value is nil.
    |  ldr TAB:CARG2w, TAB:CARG1->metatable
    |  cbz TAB:CARG2w, <1    // No metatable: done.
    |  ldrb CARG2w, TAB:CARG2->nomm
    |  tst CARG2w, #1<<MM_index
    |  b.ne <1                // 'no __index' flag set: done.
    |  b ->vmeta_tgetb
    break;
  case BC_TGETR:
    |  decode_RB8 RBw, INSw
    |   decode_RC8 RCw, INSw
    |  // RA = dst*8, RB = table*8, RC = key*8
    |  add RA, BASE, RA
    |  ldr TAB:CARG1w, [BASE, RB]
    |   ldr CARG2w, [BASE, RC]
    |  ldr CARG4w, TAB:CARG1->array
    |    ldr CARG3w, TAB:CARG1->asize
    |  add CARG4, CARG4, CARG2, lsl #3
    |    cmp CARG2w, CARG3w        // In array part?
    |    b.hs ->vmeta_tgetr
    |  ldp CARG1w, CARG2w, [CARG4]
    |->BC_TGETR_Z:
    |   ins_next1
    |   ins_next2
    |  stp CARG1w, CARG2w, [RA]
    |   ins_next3
    break;

  case BC_TSETV:
    |  decode_RB8 RBw, INSw
    |   decode_RC8 RCw, INSw
    |  // RA = src*8, RB = table*8, RC = key*8
    |  add RB, BASE, RB
    |  add RC, BASE, RC
    |  ldp TAB:CARG1w, CARG2w, [RB]
    |   ldp CARG3w, CARG4w, [RC]
    |  checktab CARG2w, ->vmeta_tsetv  // STALL: load CARG12.
    |   checktp CARG4w, LJ_TISNUM    // Integer key?
    |   b.ne >9
    |  ldr CARG2w, TAB:CARG1->array
    |    ldr CARG4w, TAB:CARG1->asize
    |
    |  add CARG2w, CARG2w, CARG3w, lsl #3
    |    cmp CARG3w, CARG4w        // In array part?
    |    b.hs ->vmeta_tsetv
    |  ldr INSw, [CARG2, #4]
    |  checktp INSw, LJ_TNIL
    |  ldrb INSw, TAB:CARG1->marked
    |   ldr CARG3, [BASE, RA]
    |  b.eq >5
    |1:
    |   ins_next1  // Overwrites RB!
    |  tst INSw, #LJ_GC_BLACK        // isblack(table)
    |   str CARG3, [CARG2]
    |  b.ne >7
    |2:
    |   ins_next2
    |   ins_next3
    |
    |5:  // Check for __newindex if previous value is nil.
    |  ldr TAB:INSw, TAB:CARG1->metatable
    |  cbz TAB:INSw, <1       // No metatable: done.
    |  ldrb INSw, TAB:INS->nomm
    |  tst INSw, #1<<MM_newindex
    |  b.ne <1                // 'no __newindex' flag set: done.
    |  b ->vmeta_tsetv
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:CARG1w, INSw, CARG3w
    |  b <2
    |
    |9:
    |  checktp CARG4w, LJ_TSTR        // String key?
    |   csel STR:RCw, CARG3w, RCw, eq
    |  b.eq ->BC_TSETS_Z
    |  b ->vmeta_tsetv
    break;
  case BC_TSETS:
    |  decode_RB8 RBw, INSw
    |   and RC, RC, #255
    |  // RA = src*8, RB = table*8, RC = str_const (~)
    |  add RB, BASE, RB
    |  ldp CARG1w, CARG2w, [RB]
    |   mvn RC, RC
    |   ldr STR:RCw, [KBASE, RC, lsl #2]  // STALL: early RC.
    |  checktab CARG2w, ->vmeta_tsets1
    |->BC_TSETS_Z:
    |  // (TAB:RB =) TAB:CARG1 = GCtab *, STR:RC = GCstr *, RA = dst*8
    |  ldr CARG3w, TAB:CARG1->hmask
    |   ldr CARG4w, STR:RC->hash
    |    ldr NODE:INSw, TAB:CARG1->node
    |     mov TAB:RB, TAB:CARG1
    |  and CARG3, CARG3, CARG4            // idx = str->hash & tab->hmask
    |  add CARG3, CARG3, CARG3, lsl #1
    |   mov CARG4, #0
    |    add NODE:INS, NODE:INS, CARG3, lsl #3    // node = tab->node + idx*3*8
    |   strb CARG4w, TAB:RB->nomm        // Clear metamethod cache.
    |1:
    |  ldp CARG1w, CARG2w, NODE:INS->key
    |   ldr CARG4w, NODE:INS->val.it
    |    ldr NODE:CARG3w, NODE:INS->next
    |  checktp CARG2w, LJ_TSTR
    |  ccmp CARG1, STR:RC, #0, eq
    |  b.ne >5
    |  ldrb CARG2w, TAB:RB->marked
    |   checktp CARG4w, LJ_TNIL        // Key found, but nil value?
    |    ldr CARG3, [BASE, RA]
    |   b.eq >4
    |2:
    |  tst CARG2w, #LJ_GC_BLACK        // isblack(table)
    |    str CARG3, NODE:INS->val
    |  b.ne >7
    |3:
    |   ins_next
    |
    |4:  // Check for __newindex if previous value is nil.
    |  ldr TAB:CARG1w, TAB:RB->metatable
    |  cbz TAB:CARG1w, <2    // No metatable: done.
    |  ldrb CARG1w, TAB:CARG1->nomm
    |  tst CARG1w, #1<<MM_newindex
    |  b.ne <2                // 'no __newindex' flag set: done.
    |  b ->vmeta_tsets
    |
    |5:  // Follow hash chain.
    |  mov NODE:INS, NODE:CARG3
    |  cbnz NODE:INS, <1
    |  // End of hash chain: key not found, add a new one.
    |
    |  // But check for __newindex first.
    |  ldr TAB:CARG4w, TAB:RB->metatable
    |   mov CARG3, TMPDp
    |   str PCw, SAVE_PC
    |   str BASE, L->base
    |   mov CARG1, L
    |  cbz TAB:CARG4w, >6       // No metatable: continue.
    |  ldrb CARG2w, TAB:CARG4->nomm
    |  tst CARG2w, #1<<MM_newindex
    |  b.eq ->vmeta_tsets        // 'no __newindex' flag NOT set: check.
    |6:
    |  mov CARG4w, #LJ_TSTR
    |   mov CARG2, TAB:RB
    |  stp STR:RCw, CARG4w, TMPD
    |  bl extern lj_tab_newkey        // (lua_State *L, GCtab *t, TValue *k)
    |  // Returns TValue *.
    |  ldr BASE, L->base
    |  ldr CARG3, [RA]
    |  str CARG3, [CRET1]
    |  b <3                // No 2nd write barrier needed.
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:RBw, CARG2w, CARG3w
    |  b <3
    break;
  case BC_TSETB: 
    |  decode_RB8 RB, INS
    |   and RC, RC, #255
    |  // RA = src*8, RB = table*8, RC = index
    |  add RB, BASE, RB
    |  ldp CARG1w, CARG2w, [RB]
    |  checktab CARG2w, ->vmeta_tsetb  // STALL: load CARG12.
    |   ldr CARG3w, TAB:CARG1->asize
    |  ldr RBw, TAB:CARG1->array
    |  add CARG2, RB, RC, lsl #3
    |   cmp RC, CARG3
    |   b.hs ->vmeta_tsetb
    |  ldr CARG4w, [CARG2, #4]
    |  checktp CARG4w, LJ_TNIL
    |  ldrb INSw, TAB:CARG1->marked
    |   ldr CARG3, [BASE, RA]
    |  b.eq >5
    |1:
    |   ins_next1  // Overwrites RB!
    |  tst INSw, #LJ_GC_BLACK        // isblack(table)
    |    str CARG3, [CARG2]
    |  b.ne >7
    |2:
    |   ins_next2
    |   ins_next3
    |
    |5:  // Check for __newindex if previous value is nil.
    |  ldr TAB:CARG4w, TAB:CARG1->metatable
    |  cbz TAB:CARG4w, <1    // No metatable: done.
    |  ldrb CARG4w, TAB:CARG4->nomm
    |  tst CARG4w, #1<<MM_newindex
    |  b.ne <1                // 'no __newindex' flag set: done.
    |  b ->vmeta_tsetb        // RB = table, RC = index
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:CARG1w, INSw, CARG3w
    |  b <2
    break;
  case BC_TSETR:
    |  decode_RB8 RBw, INSw
    |   decode_RC8 RCw, INSw
    |  // RA = dst*8, RB = table*8, RC = key*8
    |  ldr TAB:CARG2w, [BASE, RB]
    |   ldr CARG3w, [BASE, RC]
    |     ldrb INSw, TAB:CARG2->marked
    |  ldr CARG1w, TAB:CARG2->array
    |    ldr CARG4w, TAB:CARG2->asize
    |     tst INSw, #LJ_GC_BLACK        // isblack(table)
    |  add CARG1, CARG1, CARG3, lsl #3
    |     b.ne >7
    |2:
    |    cmp CARG3w, CARG4w        // In array part?
    |    b.hs ->vmeta_tsetr
    |->BC_TSETR_Z:
    |  ldr CARG3, [BASE, RA]
    |   ins_next1
    |   ins_next2
    |  str CARG3, [CARG1]
    |   ins_next3
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:CARG2w, INSw, RBw
    |  b <2
    break;

  case BC_TSETM:
    |  // RA = base*8 (table at base-1), RC = num_const (start index)
    |  add RA, BASE, RA
    |1:
    |   ldr RBw, SAVE_MULTRES
    |  ldr TAB:CARG2w, [RA, #-8]        // Guaranteed to be a table.
    |  ldr CARG1w, [KBASE, RC, lsl #3]    // Integer constant is in lo-word.
    |   subs RB, RB, #8
    |  ldr CARG4w, TAB:CARG2->asize
    |   b.eq >4                // Nothing to copy?
    |  add CARG3w, CARG1w, RBw, lsr #3
    |  cmp CARG3w, CARG4w
    |   ldr CARG4w, TAB:CARG2->array
    |    add RB, RA, RB
    |  b.hi >5
    |   add INSw, CARG4w, CARG1w, lsl #3
    |    ldrb CARG1w, TAB:CARG2->marked
    |3:  // Copy result slots to table.
    |   ldr CARG3, [RA], #8
    |   str CARG3, [INS], #8
    |  cmp RA, RB
    |  b.lo <3
    |    tst CARG1w, #LJ_GC_BLACK    // isblack(table)
    |    b.ne >7
    |4:
    |  ins_next
    |
    |5:  // Need to resize array part.
    |   str BASE, L->base
    |  mov CARG1, L
    |   str PCw, SAVE_PC
    |  bl extern lj_tab_reasize        // (lua_State *L, GCtab *t, int nasize)
    |  // Must not reallocate the stack.
    |  b <1
    |
    |7:  // Possible table write barrier for any value. Skip valiswhite check.
    |  barrierback TAB:CARG2w, CARG1w, CARG3w
    |  b <4
    break;

  /* -- Calls and vararg handling ----------------------------------------- */

  case BC_CALLM:
    |  // RA = base*8, (RB = nresults+1,) RC = extra_nargs
    |  ldr CARG1w, SAVE_MULTRES
    |  decode_RC8 NARGS8:RCw, INSw
    |  add NARGS8:RCw, NARGS8:RCw, CARG1w
    |  b ->BC_CALL_Z
    break;
  case BC_CALL:
    |  decode_RC8 NARGS8:RCw, INSw
    |  // RA = base*8, (RB = nresults+1,) RC = (nargs+1)*8
    |->BC_CALL_Z:
    |  mov RB, BASE            // Save old BASE for vmeta_call.
    |  add BASE, BASE, RA
    |  ldp CARG3w, CARG4w, [BASE], #8
    |   sub NARGS8:RCw, NARGS8:RCw, #8
    |  checkfunc CARG4w, ->vmeta_call
    |  ins_call
    break;

  case BC_CALLMT:
    |  // RA = base*8, (RB = 0,) RC = extra_nargs
    |  ldr CARG1w, SAVE_MULTRES
    |  add NARGS8:RCw, CARG1w, RCw, lsl #3
    |  b ->BC_CALLT1_Z
    break;
  case BC_CALLT:
    |  lsl NARGS8:RCw, RCw, #3
    |  // RA = base*8, (RB = 0,) RC = (nargs+1)*8
    |->BC_CALLT1_Z:
    |  add RA, BASE, RA
    |  ldp LFUNC:CARG3w, CARG4w, [RA], #8
    |   sub NARGS8:RC, NARGS8:RC, #8
    |  checkfunc CARG4w, ->vmeta_callt
    |  ldr PCw, [BASE, FRAME_PC]
    |->BC_CALLT2_Z:
    |   mov RB, #0
    |   ldrb CARG4w, LFUNC:CARG3->ffid
    |  tst PCw, #FRAME_TYPE
    |  b.ne >7
    |1:
    |  str LFUNC:CARG3w, [BASE, FRAME_FUNC]  // Copy function down, but keep PC.
    |  cbz NARGS8:RCw, >3
    |2:
    |  ldr CARG1, [RA, RB]
    |   add INS, RB, #8
    |   cmp INS, NARGS8:RC
    |  str CARG1, [BASE, RB]
    |    mov RB, INS
    |   b.ne <2
    |3:
    |  cmp CARG4, #1            // (> FF_C) Calling a fast function?
    |  b.hi >5
    |4:
    |  ins_callt
    |
    |5:  // Tailcall to a fast function with a Lua frame below.
    |  ldr INSw, [PC, #-4]
    |  decode_RA8 RAw, INSw
    |  sub CARG1, BASE, RA
    |  ldr LFUNC:CARG1w, [CARG1, #-16]
    |  ldr CARG1w, LFUNC:CARG1->field_pc
    |  ldr KBASEw, [CARG1, #PC2PROTO(k)]
    |  b <4
    |
    |7:  // Tailcall from a vararg function.
    |  eor PCw, PCw, #FRAME_VARG
    |  tst PCw, #FRAME_TYPEP        // Vararg frame below?
    |  csel CARG4, xzr, CARG4, ne   // Clear ffid if no Lua function below.
    |  b.ne <1
    |  sub BASE, BASE, PC
    |  ldr PCw, [BASE, FRAME_PC]
    |  tst PCw, #FRAME_TYPE
    |  csel CARG4, xzr, CARG4, ne   // Clear ffid if no Lua function below.
    |  b <1
    break;

  case BC_ITERC:
    |  // RA = base*8, (RB = nresults+1, RC = nargs+1 (2+1))
    |  add RA, BASE, RA
    |   mov RB, BASE            // Save old BASE for vmeta_call.
    |  ldr CARG3, [RA, #-16]
    |   ldrd CARG1, [RA, #-8]
    |    add BASE, RA, #8
    |  str CARG3, [RA, #8]        // Copy state.
    |   str CARG1, [RA, #16]        // Copy control var.
    |  // STALL: locked CARG34.
    |  ldp LFUNC:CARG3w, CARG4w, [RA, #-24]
    |    mov NARGS8:RC, #16        // Iterators get 2 arguments.
    |  // STALL: load CARG34.
    |  stp LFUNC:CARG3w, CARG4w, [RA]        // Copy callable.
    |  checkfunc CARG4w, ->vmeta_call
    |  ins_call
    break;

  case BC_ITERN:
    |  // RA = base*8, (RB = nresults+1, RC = nargs+1 (2+1))
    |.if JIT
    |  // NYI: add hotloop, record BC_ITERN.
    |.endif
    |  add RA, BASE, RA
    |  ldr TAB:RBw, [RA, #-16]
    |  ldr CARG1w, [RA, #-8]        // Get index from control var.
    |  ldr INSw, TAB:RB->asize
    |   ldr CARG2w, TAB:RB->array
    |    add PC, PC, #4
    |1:  // Traverse array part.
    |  subs RC, CARG1, INS
    |   add CARG3, CARG2, CARG1, lsl #3
    |  b.hs >5                // Index points after array part?
    |   ldp CARG3w, CARG4w, [CARG3]
    |   checktp CARG4w, LJ_TNIL
    |   cinc CARG1, CARG1, eq        // Skip holes in array part.
    |   b.eq <1
    |  ldrh RCw, [PC, #-2]
    |   mov CARG2w, #LJ_TISNUM
    |    stp CARG3w, CARG4w, [RA, #8]
    |  add RC, PC, RC, lsl #2
    |    add RB, CARG1, #1
    |   stp CARG1w, CARG2w, [RA]
    |  sub PC, RC, #0x20, lsl #12
    |    str RBw, [RA, #-8]        // Update control var.
    |3:
    |  ins_next
    |
    |5:  // Traverse hash part.
    |  ldr CARG4w, TAB:RB->hmask
    |   ldr NODE:RBw, TAB:RB->node
    |6:
    |   add CARG1, RC, RC, lsl #1
    |  cmp RC, CARG4            // End of iteration? Branch to ITERL+1.
    |   add NODE:CARG3, NODE:RB, CARG1, lsl #3  // node = tab->node + idx*3*8
    |  b.hi <3
    |   ldp CARG1w, CARG2w, NODE:CARG3->val
    |   checktp CARG2w, LJ_TNIL
    |   add RC, RC, #1
    |   b.eq <6                // Skip holes in hash part.
    |  ldrh RBw, [PC, #-2]
    |   add RC, RC, INS
    |    ldr CARG3, NODE:CARG3->key
    |   str RCw, [RA, #-8]        // Update control var.
    |   stp CARG1w, CARG2w, [RA, #8]
    |  add RC, PC, RB, lsl #2
    |  sub PC, RC, #0x20, lsl #12
    |    str CARG3, [RA]        // 8 bytes TValue
    |  b <3
    break;

  case BC_ISNEXT:
    |  // RA = base*8, RC = target (points to ITERN)
    |  add RA, BASE, RA
    |     add RC, PC, RC, lsl #2
    |  ldp CFUNC:CARG1w, CFUNC:CARG2w, [RA, #-24]
    |   ldr CARG3w, [RA, #-12]
    |    ldr CARG4w, [RA, #-4]
    |  checktp CARG2w, LJ_TFUNC
    |  b.ne >5
    |  ldrb CARG1w, CFUNC:CARG1->ffid
    |   checktp CARG3w, LJ_TTAB
    |    checktpeq CARG4w, LJ_TNIL
    |  ccmp CARG1w, #FF_next_N, #0, eq
    |  b.ne >5
    |     sub PC, RC, #0x20, lsl #12
    |   ins_next1
    |   ins_next2
    |  mov CARG1w, #0
    |  mov CARG2w, #~0x00018000u
    |  stp CARG1w, CARG2w, [RA, #-8]        // Initialize control var.
    |1:
    |   ins_next3
    |5:  // Despecialize bytecode if any of the checks fail.
    |  mov CARG1w, #BC_JMP
    |   mov OPw, #BC_ITERC
    |  strb CARG1w, [PC, #-4]
    |   sub PC, RC, #0x20, lsl #12
    |   strb OPw, [PC]            // Subsumes ins_next1.
    |   ins_next2
    |  b <1
    break;

  case BC_VARG:
    |  decode_RB8 RBw, INSw
    |   decode_RC8 RCw, INSw
    |  // RA = base*8, RB = (nresults+1)*8, RC = numparams*8
    |  ldr CARG1w, [BASE, FRAME_PC]
    |  add RC, BASE, RC
    |   add RA, BASE, RA
    |  add RC, RC, #FRAME_VARG
    |   add CARG4, RA, RB
    |  sub CARG3, BASE, #8        // CARG3 = vtop
    |  sub RC, RC, CARG1        // RC = vbase
    |  // Note: RC may now be even _above_ BASE if nargs was < numparams.
    |  sub CARG1, CARG3, RC
    |  cbz RB, >5                // Copy all varargs?
    |   sub CARG4, CARG4, #16
    |1:  // Copy vararg slots to destination slots.
    |  cmp RC, CARG3
    |  mov CARG2w, #LJ_TNIL
    |  b.hs >2
    |  ldp CARG1w, CARG2w, [RC], #8
    |2:
    |   cmp RA, CARG4
    |  stp CARG1w, CARG2w, [RA], #8
    |   b.lo <1
    |4:
    |  ins_next
    |
    |5:  // Copy all varargs.
    |  ldr CARG4w, L->maxstack
    |  cmp CARG1, #0
    |   mov RB, #8            // MULTRES = (0+1)*8
    |   add CARG2, CARG1, #8
    |   csel RB, CARG2, RB, gt
    |  add CARG2, RA, CARG1
    |   str RBw, SAVE_MULTRES
    |   b.le <4
    |  cmp CARG2, CARG4
    |  b.hi >7
    |6:
    |   ldr CARG1, [RC], #8
    |   str CARG1, [RA], #8
    |  cmp RC, CARG3
    |  b.lo <6
    |  b <4
    |
    |7:  // Grow stack for varargs.
    |  lsr CARG2, CARG1, #3
    |   str RA, L->top
    |  mov CARG1, L
    |   str BASE, L->base
    |  sub RC, RC, BASE            // Need delta, because BASE may change.
    |   str PCw, SAVE_PC
    |  sub RA, RA, BASE
    |  bl extern lj_state_growstack    // (lua_State *L, int n)
    |  ldr BASE, L->base
    |  add RA, BASE, RA
    |  add RC, BASE, RC
    |  sub CARG3, BASE, #8
    |  b <6
    break;

  /* -- Returns ----------------------------------------------------------- */

  case BC_RETM:
    |  // RA = results*8, RC = extra results
    |  ldr CARG1w, SAVE_MULTRES
    |   ldr PCw, [BASE, FRAME_PC]
    |    add RA, BASE, RA
    |  add RC, CARG1, RC, lsl #3
    |  b ->BC_RETM_Z
    break;

  case BC_RET:
    |  // RA = results*8, RC = nresults+1
    |  ldr PCw, [BASE, FRAME_PC]
    |   lsl RC, RC, #3
    |    add RA, BASE, RA
    |->BC_RETM_Z:
    |   str RCw, SAVE_MULTRES
    |1:
    |  ands CARG1, PC, #FRAME_TYPE
    |   eor CARG2, PC, #FRAME_VARG
    |  b.ne ->BC_RETV2_Z
    |
    |->BC_RET_Z:
    |  // BASE = base, RA = resultptr, RC = (nresults+1)*8, PC = return
    |  ldr INSw, [PC, #-4]
    |  subs CARG4, RC, #8
    |   sub CARG3, BASE, #8
    |  b.eq >3
    |2:
    |  ldr CARG1, [RA], #8
    |   add BASE, BASE, #8
    |   subs CARG4, CARG4, #8
    |  str CARG1, [BASE, #-16]
    |   b.ne <2
    |3:
    |  decode_RA8 RAw, INSw
    |  sub CARG4w, CARG3w, RAw
    |   decode_RB8 RBw, INSw
    |  ldr LFUNC:CARG1w, [CARG4, FRAME_FUNC]
    |5:
    |  cmp RB, RC            // More results expected?
    |  b.hi >6
    |  mov BASE, CARG4
    |  ldr CARG2w, LFUNC:CARG1->field_pc
    |   ins_next1
    |   ins_next2
    |  ldr KBASEw, [CARG2, #PC2PROTO(k)]
    |   ins_next3
    |
    |6:  // Fill up results with nil.
    |  mov CARG2w, #LJ_TNIL
    |  add BASE, BASE, #8
    |   add RC, RC, #8
    |  str CARG2w, [BASE, #-12]
    |  b <5
    |
    |->BC_RETV1_Z:  // Non-standard return case.
    |  add RA, BASE, RA
    |->BC_RETV2_Z:
    |  tst CARG2w, #FRAME_TYPEP
    |  b.ne ->vm_return
    |  // Return from vararg function: relocate BASE down.
    |  sub BASE, BASE, CARG2
    |  ldr PCw, [BASE, FRAME_PC]
    |  b <1
    break;

  case BC_RET0: case BC_RET1:
    |  // RA = results*8, RC = nresults+1
    |  ldr PCw, [BASE, FRAME_PC]
    |   lsl RC, RC, #3
    |   str RCw, SAVE_MULTRES
    |  ands CARG1w, PCw, #FRAME_TYPE
    |   eor CARG2w, PCw, #FRAME_VARG
    |  b.ne ->BC_RETV1_Z
    |  ldr INSw, [PC, #-4]
    if (op == BC_RET1) {
      |  ldr CARG1, [BASE, RA]    // 8 bytes
    }
    |  sub CARG4, BASE, #8
    |   decode_RA8 RAw, INSw
    if (op == BC_RET1) {
      |  str CARG1, [CARG4]
    }
    |  sub BASE, CARG4, RA
    |   decode_RB8 RBw, INSw
    |  ldr LFUNC:CARG1w, [BASE, FRAME_FUNC]
    |5:
    |  cmp RB, RC
    |  b.hi >6
    |  ldr CARG2w, LFUNC:CARG1->field_pc
    |   ins_next1
    |   ins_next2
    |  ldr KBASEw, [CARG2, #PC2PROTO(k)]
    |   ins_next3
    |
    |6:  // Fill up results with nil.
    |  sub CARG2, CARG4, #4
    |  mov CARG3w, #LJ_TNIL
    |  str CARG3w, [CARG2, RC]
    |  add RC, RC, #8
    |  b <5
    break;

  /* -- Loops and branches ------------------------------------------------ */

  |.define FOR_IDX,  [RA];      .define FOR_TIDX,  [RA, #4]
  |.define FOR_STOP, [RA, #8];  .define FOR_TSTOP, [RA, #12]
  |.define FOR_STEP, [RA, #16]; .define FOR_TSTEP, [RA, #20]
  |.define FOR_EXT,  [RA, #24]; .define FOR_TEXT,  [RA, #28]

  case BC_FORL:
    |.if JIT
    |  hotloop
    |.endif
    |  // Fall through. Assumes BC_IFORL follows.
    break;

  case BC_JFORI:
  case BC_JFORL:
#if !LJ_HASJIT
    break;
#endif
  case BC_FORI:
  case BC_IFORL:
    |  // RA = base*8, RC = target (after end of loop or start of loop)
    vk = (op == BC_IFORL || op == BC_JFORL);
    |  add RA, BASE, RA
    |  ldp CARG1w, CARG2w, [RA]
    if (op != BC_JFORL) {
      |   add RC, PC, RC, lsl #2
    }
    if (!vk) {
      |  ldp CARG3w, CARG4w, FOR_STOP
      |   checktp CARG2w, LJ_TISNUM
      |  ldr RBw, FOR_TSTEP
      |   b.ne >5
      |  checktp CARG4w, LJ_TISNUM
      |   ldr CARG4w, FOR_STEP
      |  checktpeq RBw, LJ_TISNUM
      |  b.ne ->vmeta_for
      |  cmp CARG4w, #0
      |  b.lt >4
      |  cmp CARG1w, CARG3w
    } else {
      |  ldp CARG3w, CARG4w, FOR_STEP
      |   checktp CARG2w, LJ_TISNUM
      |   b.ne >5
      |  adds CARG1w, CARG1w, CARG3w
      |   ldr CARG4w, FOR_STOP
      if (op == BC_IFORL) {
    |  add CARG5, PC, #0x20, lsl #12
    |  csel RC, CARG5, RC, vs        // Overflow: prevent branch.
      } else {
    |  b.vs >2                // Overflow: do not enter mcode.
      }
      |  cmp CARG3w, #0
      |  b.lt >4
      |  cmp CARG1w, CARG4w
    }
    |1:
    if (op == BC_FORI) {
      |  sub CARG5, RC, #0x20, lsl #12
      |  csel PC, CARG5, PC, gt
    } else if (op == BC_JFORI) {
      |  sub PC, RC, #0x20, lsl #12
      |  ldrh CARG5w, [PC, #-2]
      |  csel RC, CARG5, RC, le
    } else if (op == BC_IFORL) {
      |  sub CARG5, RC, #0x20, lsl #12
      |  csel PC, CARG5, PC, le
    }
    if (vk) {
      |  stp CARG1w, CARG2w, FOR_IDX
    }
    |2:
    |   ins_next1
    |   ins_next2
    |  stp CARG1w, CARG2w, FOR_EXT
    if (op == BC_JFORI || op == BC_JFORL) {
      |  b.le =>BC_JLOOP
    }
    |3:
    |   ins_next3
    |
    |4:  // Invert check for negative step.
    if (!vk) {
      |  cmp CARG3w, CARG1w
    } else {
      |  cmp CARG4w, CARG1w
    }
    |  b <1
    |
    |5:  // FP loop.
    if (!vk) {
      |  ccmn CARG4w, #-LJ_TISNUM, #2, lo
      |  ccmn RBw, #-LJ_TISNUM, #2, lo
      |  b.hs ->vmeta_for
      |.if FPU
      |  ldr d0, FOR_IDX
      |  ldr d1, FOR_STOP
      |  cmp RBw, #0
      |  str d0, FOR_EXT
      |.else
      |  cmp RBw, #0
      |   stp CARG1w, CARG2w, FOR_EXT
      |  b.lt >8
      |.endif
    } else {
      |.if FPU
      |  ldr d0, FOR_IDX
      |  ldr d2, FOR_STEP
      |  ldr d1, FOR_STOP
      |  cmp CARG4w, #0
      |  fadd d0, d0, d2
      |.else
      |  cmp CARG4w, #0
      |  b.lt >8
      |  bl extern __aeabi_dadd
      |   stp CARG1w, CARG2w, FOR_IDX
      |  ldp CARG3w, CARG4w, FOR_STOP
      |   stp CARG1w, CARG2w, FOR_EXT
      |.endif
    }
    |6:
    |.if FPU
    |  fccmp d0, d1, #1, ge   // nzcv: lt: n!=v, ge: n==v
    |  fccmp d1, d0, #0, lt
    |.else
    |  bl extern __aeabi_cdcmple
    |.endif
    if (vk) {
      |.if FPU
      |  str d0, FOR_IDX
      |  str d0, FOR_EXT
      |.endif
    }
    if (op == BC_FORI) {
      |  sub CARG5, RC, #0x20, lsl #12
      |  csel PC, CARG5, PC, hi
    } else if (op == BC_JFORI) {
      |  sub PC, RC, #0x20, lsl #12
      |  ldrh CARG5w, [PC, #-2]
      |  csel RC, CARG5, RC, ls
      |  b.ls =>BC_JLOOP
    } else if (op == BC_IFORL) {
      |  sub CARG5, RC, #0x20, lsl #12
      |  csel PC, CARG5, PC, ls
    } else {
      |  b.ls =>BC_JLOOP
    }
    |  ins_next1
    |  ins_next2
    |  b <3
    |
    |.if not FPU
    |8:  // Invert check for negative step.
    if (vk) {
      |  bl extern __aeabi_dadd
      |  stp CARG1w, CARG2w, FOR_IDX
      |  stp CARG1w, CARG2w, FOR_EXT
    }
    |  mov CARG3, CARG1
    |  mov CARG4, CARG2
    |  ldp CARG1w, CARG2w, FOR_STOP
    |  b <6
    |.endif
    break;

  case BC_ITERL:
    |.if JIT
    |  hotloop
    |.endif
    |  // Fall through. Assumes BC_IITERL follows.
    break;

  case BC_JITERL:
#if !LJ_HASJIT
    break;
#endif
  case BC_IITERL:
    |  // RA = base*8, RC = target
    |  add RA, BASE, RA
    |  ldp CARG1w, CARG2w, [RA]
    if (op == BC_JITERL) {
      |  cmn CARG2w, #-LJ_TNIL        // Stop if iterator returned nil.
      |  b.eq >1
      |  stp CARG1w, CARG2w, [RA, #-8]
      |  b =>BC_JLOOP
    } else {
      |   add RC, PC, RC, lsl #2
      |  // STALL: load CARG12.
      |  cmn CARG2w, #-LJ_TNIL        // Stop if iterator returned nil.
      |  b.eq >1
      |  sub PC, RC, #0x20, lsl #12        // Otherwise save control var + branch.
      |  stp CARG1w, CARG2w, [RA, #-8]
    }
    |1:
    |  ins_next
    break;

  case BC_LOOP:
    |  // RA = base*8, RC = target (loop extent)
    |  // Note: RA/RC is only used by trace recorder to determine scope/extent
    |  // This opcode does NOT jump, it's only purpose is to detect a hot loop.
    |.if JIT
    |  hotloop
    |.endif
    |  // Fall through. Assumes BC_ILOOP follows.
    break;

  case BC_ILOOP:
    |  // RA = base*8, RC = target (loop extent)
    |  ins_next
    break;

  case BC_JLOOP:
    |.if JIT
    |  // RA = base (ignored), RC = traceno
    |  ldr CARG1, [DISPATCH, #DISPATCH_J(trace)]   // 8-byte pointer
    |   mov CARG2, #0  // Traces on ARM don't store the trace number, so use 0.
    |  ldr TRACE:RCw, [CARG1, RC, lsl #2]     // 4-byte pointer
    |   st_vmstate CARG2w
    |  ldr RA, TRACE:RC->mcode          //8-byte pointer
    |   str BASEw, [DISPATCH, #DISPATCH_GL(jit_base)]     //4-byte pointer
    |   str Lw, [DISPATCH, #DISPATCH_GL(tmpbuf.L)]    //4-byte pointer
    |  br RA
    |.endif
    break;

  case BC_JMP:
    |  // RA = base*8 (only used by trace recorder), RC = target
    |  add RC, PC, RC, lsl #2
    |  sub PC, RC, #0x20, lsl #12
    |  ins_next
    break;

  /* -- Function headers -------------------------------------------------- */

  case BC_FUNCF:
    |.if JIT
    |  hotcall
    |.endif
  case BC_FUNCV:  /* NYI: compiled vararg functions. */
    |  // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow.
    break;

  case BC_JFUNCF:
#if !LJ_HASJIT
    break;
#endif
  case BC_IFUNCF:
    |  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    |  ldr CARG1w, L->maxstack
    |   ldrb CARG2w, [PC, #-4+PC2PROTO(numparams)]
    |    ldr KBASEw, [PC, #-4+PC2PROTO(k)]
    |  cmp RA, CARG1
    |  b.hi ->vm_growstack_l
    if (op != BC_JFUNCF) {
      |  ins_next1
      |  ins_next2
    }
    |  add RC, BASE, RC
    |  add CARG2, BASE, CARG2, lsl #3
    |2:
    |  cmp RC, CARG2    // Check for missing parameters.
    |   mov CARG4w, #LJ_TNIL
    |  b.lo >3
    if (op == BC_JFUNCF) {
      |  decode_RD RCw, INSw
      |  b =>BC_JLOOP
    } else {
      |  ins_next3
    }
    |
    |3:  // Clear missing parameters.
    |  stp CARG3w, CARG4w, [RC], #8
    |  b <2
    break;

  case BC_JFUNCV:
#if !LJ_HASJIT
    break;
#endif
    |  NYI  // NYI: compiled vararg functions
    break;  /* NYI: compiled vararg functions. */

  case BC_IFUNCV:
    |  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    |  ldr CARG1w, L->maxstack
    |   add CARG4, BASE, RC
    |  add RA, RA, RC
    |   str LFUNC:CARG3w, [CARG4]    // Store copy of LFUNC.
    |   add CARG2, RC, #8+FRAME_VARG
    |    ldr KBASEw, [PC, #-4+PC2PROTO(k)]
    |  cmp RA, CARG1
    |   str CARG2w, [CARG4, #4]        // Store delta + FRAME_VARG.
    |  b.hs ->vm_growstack_l
    |  ldrb RBw, [PC, #-4+PC2PROTO(numparams)]
    |   mov RA, BASE
    |   mov RC, CARG4
    |   add BASE, CARG4, #8
    |  cbz RB, >3
    |  mov CARG3w, #LJ_TNIL
    |1:
    |  cmp RA, RC            // Less args than parameters?
    |   mov CARG2, CARG3
    |   b.hs >2
    |   ldp CARG1w, CARG2w, [RA], #8
    |    str CARG3w, [RA, #-4]        // Clear old fixarg slot (help the GC).
    |2:
    |  subs RB, RB, #1
    |   stp CARG1w, CARG2w, [CARG4, #8]!
    |  b.ne <1
    |3:
    |  ins_next
    break;

  case BC_FUNCC:
  case BC_FUNCCW:
    |  // BASE = new base, RA = BASE+framesize*8, CARG3 = CFUNC, RC = nargs*8
    if (op == BC_FUNCC) {
      |  ldr CARG4, CFUNC:CARG3->f       // 8-byte pointer
    } else {
      |  ldr CARG4, [DISPATCH, #DISPATCH_GL(wrapf)]        // 8-byte pointer
    }
    |   add CARG2, RA, NARGS8:RC
    |   ldr CARG1w, L->maxstack
    |  add RC, BASE, NARGS8:RC
    |    str BASE, L->base
    |   cmp CARG2, CARG1
    |  str RC, L->top
    if (op == BC_FUNCCW) {
      |  ldr CARG2, CFUNC:CARG3->f
    }
    |    mv_vmstate CARG3w, C
    |  mov CARG1, L
    |   b.hi ->vm_growstack_c        // Need to grow stack.
    |    st_vmstate CARG3w
    |  blr CARG4            // (lua_State *L [, lua_CFunction f])
    |  // Returns nresults.
    |  ldr BASE, L->base
    |    mv_vmstatew CARG3, INTERP
    |   ldr CRET2, L->top
    |    str Lw, [DISPATCH, #DISPATCH_GL(cur_L)]
    |   lsl RC, CRET1, #3
    |    st_vmstate CARG3w
    |  ldr PCw, [BASE, FRAME_PC]
    |   sub RA, CRET2, RC        // RA = L->top - nresults*8
    |  b ->vm_returnc
    break;

  /* ---------------------------------------------------------------------- */

  default:
    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
    exit(2);
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;

  dasm_growpc(Dst, BC__MAX);

  build_subroutines(ctx);

  |.code_op
  for (op = 0; op < BC__MAX; op++)
    build_ins(ctx, (BCOp)op, op);

  return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions. */
static void emit_asm_debug(BuildCtx *ctx)
{
  int fcofs = (int)((uint8_t *)ctx->glob[GLOB_vm_ffi_call] - ctx->code);
  int i;
  switch (ctx->mode) {
  case BUILD_elfasm:
    fprintf(ctx->fp, "\t.section .debug_frame,\"\",%%progbits\n");
    fprintf(ctx->fp,
    ".Lframe0:\n"
    "\t.long .LECIE0-.LSCIE0\n"
    ".LSCIE0:\n"
    "\t.long 0xffffffff\n"
    "\t.byte 0x1\n"
    "\t.string \"\"\n"
    "\t.uleb128 0x1\n"
    "\t.sleb128 -4\n"
    "\t.byte 0xe\n"                /* Return address is in lr. */
    "\t.byte 0xc\n\t.uleb128 0xd\n\t.uleb128 0\n"    /* def_cfa sp */
    "\t.align 2\n"
    ".LECIE0:\n\n");
    fprintf(ctx->fp,
    ".LSFDE0:\n"
    "\t.long .LEFDE0-.LASFDE0\n"
    ".LASFDE0:\n"
    "\t.long .Lframe0\n"
    "\t.long .Lbegin\n"
    "\t.long %d\n"
    "\t.byte 0xe\n\t.uleb128 %d\n"        /* def_cfa_offset */
    "\t.byte 0x8e\n\t.uleb128 1\n",        /* offset lr */
    fcofs, CFRAME_SIZE);
    for (i = 11; i >= (LJ_ARCH_HASFPU ? 5 : 4); i--)  /* offset r4-r11 */
      fprintf(ctx->fp, "\t.byte %d\n\t.uleb128 %d\n", 0x80+i, 2+(11-i));
#if LJ_ARCH_HASFPU
    for (i = 15; i >= 8; i--)  /* offset d8-d15 */
      fprintf(ctx->fp, "\t.byte 5\n\t.uleb128 %d, %d\n",
    64+2*i, 10+2*(15-i));
    fprintf(ctx->fp, "\t.byte 0x84\n\t.uleb128 %d\n", 25);  /* offset r4 */
#endif
    fprintf(ctx->fp,
    "\t.align 2\n"
    ".LEFDE0:\n\n");
#if LJ_HASFFI
    fprintf(ctx->fp,
    ".LSFDE1:\n"
    "\t.long .LEFDE1-.LASFDE1\n"
    ".LASFDE1:\n"
    "\t.long .Lframe0\n"
    "\t.long lj_vm_ffi_call\n"
    "\t.long %d\n"
    "\t.byte 0xe\n\t.uleb128 16\n"        /* def_cfa_offset */
    "\t.byte 0x8e\n\t.uleb128 1\n"        /* offset lr */
    "\t.byte 0x8b\n\t.uleb128 2\n"        /* offset r11 */
    "\t.byte 0x85\n\t.uleb128 3\n"        /* offset r5 */
    "\t.byte 0x84\n\t.uleb128 4\n"        /* offset r4 */
    "\t.byte 0xd\n\t.uleb128 0xb\n"        /* def_cfa_register r11 */
    "\t.align 2\n"
    ".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
#endif
    break;
  default:
    break;
  }
}

